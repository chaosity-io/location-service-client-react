/**
 * @public
 * @enum
 */
export declare const TypePlacement: {
    readonly AFTER_BASE_NAME: "AfterBaseName";
    readonly BEFORE_BASE_NAME: "BeforeBaseName";
};
/**
 * @public
 */
export type TypePlacement = (typeof TypePlacement)[keyof typeof TypePlacement];
/**
 * @public
 * @enum
 */
export declare const AutocompleteAdditionalFeature: {
    readonly CORE: "Core";
};
/**
 * @public
 */
export type AutocompleteAdditionalFeature = (typeof AutocompleteAdditionalFeature)[keyof typeof AutocompleteAdditionalFeature];
/**
 * @public
 * @enum
 */
export declare const AutocompleteFilterPlaceType: {
    readonly LOCALITY: "Locality";
    readonly POSTAL_CODE: "PostalCode";
};
/**
 * @public
 */
export type AutocompleteFilterPlaceType = (typeof AutocompleteFilterPlaceType)[keyof typeof AutocompleteFilterPlaceType];
/**
 * @public
 * @enum
 */
export declare const AutocompleteIntendedUse: {
    /**
     * Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
     */
    readonly SINGLE_USE: "SingleUse";
};
/**
 * @public
 */
export type AutocompleteIntendedUse = (typeof AutocompleteIntendedUse)[keyof typeof AutocompleteIntendedUse];
/**
 * @public
 * @enum
 */
export declare const PostalCodeMode: {
    readonly ENUMERATE_SPANNED_LOCALITIES: "EnumerateSpannedLocalities";
    readonly MERGE_ALL_SPANNED_LOCALITIES: "MergeAllSpannedLocalities";
};
/**
 * @public
 */
export type PostalCodeMode = (typeof PostalCodeMode)[keyof typeof PostalCodeMode];
/**
 * @public
 * @enum
 */
export declare const PlaceType: {
    readonly BLOCK: "Block";
    readonly COUNTRY: "Country";
    readonly DISTRICT: "District";
    readonly INTERPOLATED_ADDRESS: "InterpolatedAddress";
    readonly INTERSECTION: "Intersection";
    readonly LOCALITY: "Locality";
    readonly POINT_ADDRESS: "PointAddress";
    readonly POINT_OF_INTEREST: "PointOfInterest";
    readonly POSTAL_CODE: "PostalCode";
    readonly REGION: "Region";
    readonly SECONDARY_ADDRESS: "SecondaryAddress";
    readonly STREET: "Street";
    readonly SUB_BLOCK: "SubBlock";
    readonly SUB_DISTRICT: "SubDistrict";
    readonly SUB_REGION: "SubRegion";
};
/**
 * @public
 */
export type PlaceType = (typeof PlaceType)[keyof typeof PlaceType];
/**
 * @public
 * @enum
 */
export declare const ValidationExceptionReason: {
    /**
     *     The input cannot be parsed. For example a required JSON document, ARN identifier,
     *     date value, or numeric field cannot be parsed.
     *
     */
    readonly CANNOT_PARSE: "CannotParse";
    /**
     *     The input is present and parsable, but it is otherwise invalid. For example, a
     *     required numeric argument is outside the allowed range.
     *
     */
    readonly FIELD_VALIDATION_FAILED: "FieldValidationFailed";
    /**
     * The required input is missing.
     */
    readonly MISSING: "Missing";
    /**
     * The input is invalid but no more specific reason is applicable.
     */
    readonly OTHER: "Other";
    /**
     * No such field is supported.
     */
    readonly UNKNOWN_FIELD: "UnknownField";
    /**
     * No such operation is supported.
     */
    readonly UNKNOWN_OPERATION: "UnknownOperation";
};
/**
 * @public
 */
export type ValidationExceptionReason = (typeof ValidationExceptionReason)[keyof typeof ValidationExceptionReason];
/**
 * @public
 * @enum
 */
export declare const GeocodeAdditionalFeature: {
    readonly ACCESS: "Access";
    readonly INTERSECTIONS: "Intersections";
    readonly SECONDARY_ADDRESSES: "SecondaryAddresses";
    readonly TIME_ZONE: "TimeZone";
};
/**
 * @public
 */
export type GeocodeAdditionalFeature = (typeof GeocodeAdditionalFeature)[keyof typeof GeocodeAdditionalFeature];
/**
 * @public
 * @enum
 */
export declare const GeocodeFilterPlaceType: {
    readonly INTERPOLATED_ADDRESS: "InterpolatedAddress";
    readonly INTERSECTION: "Intersection";
    readonly LOCALITY: "Locality";
    readonly POINT_ADDRESS: "PointAddress";
    readonly POSTAL_CODE: "PostalCode";
    readonly STREET: "Street";
};
/**
 * @public
 */
export type GeocodeFilterPlaceType = (typeof GeocodeFilterPlaceType)[keyof typeof GeocodeFilterPlaceType];
/**
 * @public
 * @enum
 */
export declare const GeocodeIntendedUse: {
    /**
     * Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
     */
    readonly SINGLE_USE: "SingleUse";
    /**
     * Indicates that results of the operation may be stored locally.
     */
    readonly STORAGE: "Storage";
};
/**
 * @public
 */
export type GeocodeIntendedUse = (typeof GeocodeIntendedUse)[keyof typeof GeocodeIntendedUse];
/**
 * @public
 * @enum
 */
export declare const PostalAuthority: {
    readonly USPS: "Usps";
};
/**
 * @public
 */
export type PostalAuthority = (typeof PostalAuthority)[keyof typeof PostalAuthority];
/**
 * @public
 * @enum
 */
export declare const PostalCodeType: {
    readonly USPS_ZIP: "UspsZip";
    readonly USPS_ZIP_PLUS_4: "UspsZipPlus4";
};
/**
 * @public
 */
export type PostalCodeType = (typeof PostalCodeType)[keyof typeof PostalCodeType];
/**
 * @public
 * @enum
 */
export declare const ZipClassificationCode: {
    readonly MILITARY: "Military";
    readonly POST_OFFICE_BOXES: "PostOfficeBoxes";
    readonly UNIQUE: "Unique";
};
/**
 * @public
 */
export type ZipClassificationCode = (typeof ZipClassificationCode)[keyof typeof ZipClassificationCode];
/**
 * @public
 * @enum
 */
export declare const RecordTypeCode: {
    readonly FIRM: "Firm";
    readonly GENERAL: "General";
    readonly HIGH_RISE: "HighRise";
    readonly POST_OFFICE_BOX: "PostOfficeBox";
    readonly RURAL: "Rural";
    readonly STREET: "Street";
};
/**
 * @public
 */
export type RecordTypeCode = (typeof RecordTypeCode)[keyof typeof RecordTypeCode];
/**
 * @public
 * @enum
 */
export declare const GetPlaceAdditionalFeature: {
    readonly ACCESS: "Access";
    readonly CONTACT: "Contact";
    readonly PHONEMES: "Phonemes";
    readonly SECONDARY_ADDRESSES: "SecondaryAddresses";
    readonly TIME_ZONE: "TimeZone";
};
/**
 * @public
 */
export type GetPlaceAdditionalFeature = (typeof GetPlaceAdditionalFeature)[keyof typeof GetPlaceAdditionalFeature];
/**
 * @public
 * @enum
 */
export declare const GetPlaceIntendedUse: {
    /**
     * Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
     */
    readonly SINGLE_USE: "SingleUse";
    /**
     * Indicates that results of the operation may be stored locally.
     */
    readonly STORAGE: "Storage";
};
/**
 * @public
 */
export type GetPlaceIntendedUse = (typeof GetPlaceIntendedUse)[keyof typeof GetPlaceIntendedUse];
/**
 * @public
 * @enum
 */
export declare const ReverseGeocodeAdditionalFeature: {
    readonly ACCESS: "Access";
    readonly INTERSECTIONS: "Intersections";
    readonly TIME_ZONE: "TimeZone";
};
/**
 * @public
 */
export type ReverseGeocodeAdditionalFeature = (typeof ReverseGeocodeAdditionalFeature)[keyof typeof ReverseGeocodeAdditionalFeature];
/**
 * @public
 * @enum
 */
export declare const ReverseGeocodeFilterPlaceType: {
    readonly INTERPOLATED_ADDRESS: "InterpolatedAddress";
    readonly INTERSECTION: "Intersection";
    readonly LOCALITY: "Locality";
    readonly POINT_ADDRESS: "PointAddress";
    readonly STREET: "Street";
};
/**
 * @public
 */
export type ReverseGeocodeFilterPlaceType = (typeof ReverseGeocodeFilterPlaceType)[keyof typeof ReverseGeocodeFilterPlaceType];
/**
 * @public
 * @enum
 */
export declare const ReverseGeocodeIntendedUse: {
    /**
     * Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
     */
    readonly SINGLE_USE: "SingleUse";
    /**
     * Indicates that results of the operation may be stored locally.
     */
    readonly STORAGE: "Storage";
};
/**
 * @public
 */
export type ReverseGeocodeIntendedUse = (typeof ReverseGeocodeIntendedUse)[keyof typeof ReverseGeocodeIntendedUse];
/**
 * @public
 * @enum
 */
export declare const SearchNearbyAdditionalFeature: {
    readonly ACCESS: "Access";
    readonly CONTACT: "Contact";
    readonly PHONEMES: "Phonemes";
    readonly TIME_ZONE: "TimeZone";
};
/**
 * @public
 */
export type SearchNearbyAdditionalFeature = (typeof SearchNearbyAdditionalFeature)[keyof typeof SearchNearbyAdditionalFeature];
/**
 * @public
 * @enum
 */
export declare const SearchNearbyIntendedUse: {
    /**
     * Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
     */
    readonly SINGLE_USE: "SingleUse";
    /**
     * Indicates that results of the operation may be stored locally.
     */
    readonly STORAGE: "Storage";
};
/**
 * @public
 */
export type SearchNearbyIntendedUse = (typeof SearchNearbyIntendedUse)[keyof typeof SearchNearbyIntendedUse];
/**
 * @public
 * @enum
 */
export declare const SearchTextAdditionalFeature: {
    readonly ACCESS: "Access";
    readonly CONTACT: "Contact";
    readonly PHONEMES: "Phonemes";
    readonly TIME_ZONE: "TimeZone";
};
/**
 * @public
 */
export type SearchTextAdditionalFeature = (typeof SearchTextAdditionalFeature)[keyof typeof SearchTextAdditionalFeature];
/**
 * @public
 * @enum
 */
export declare const SearchTextIntendedUse: {
    /**
     * Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
     */
    readonly SINGLE_USE: "SingleUse";
    /**
     * Indicates that results of the operation may be stored locally.
     */
    readonly STORAGE: "Storage";
};
/**
 * @public
 */
export type SearchTextIntendedUse = (typeof SearchTextIntendedUse)[keyof typeof SearchTextIntendedUse];
/**
 * @public
 * @enum
 */
export declare const SuggestAdditionalFeature: {
    readonly ACCESS: "Access";
    readonly CORE: "Core";
    readonly PHONEMES: "Phonemes";
    readonly TIME_ZONE: "TimeZone";
};
/**
 * @public
 */
export type SuggestAdditionalFeature = (typeof SuggestAdditionalFeature)[keyof typeof SuggestAdditionalFeature];
/**
 * @public
 * @enum
 */
export declare const SuggestIntendedUse: {
    /**
     * Indicates that results of the operation are for single use, e.g., displaying results on a map or presenting options to users.
     */
    readonly SINGLE_USE: "SingleUse";
};
/**
 * @public
 */
export type SuggestIntendedUse = (typeof SuggestIntendedUse)[keyof typeof SuggestIntendedUse];
/**
 * @public
 * @enum
 */
export declare const QueryType: {
    readonly BUSINESS_CHAIN: "BusinessChain";
    readonly CATEGORY: "Category";
};
/**
 * @public
 */
export type QueryType = (typeof QueryType)[keyof typeof QueryType];
/**
 * @public
 * @enum
 */
export declare const SuggestResultItemType: {
    readonly PLACE: "Place";
    readonly QUERY: "Query";
};
/**
 * @public
 */
export type SuggestResultItemType = (typeof SuggestResultItemType)[keyof typeof SuggestResultItemType];
