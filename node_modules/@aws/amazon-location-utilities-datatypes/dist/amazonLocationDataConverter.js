(function(global,factory){if(typeof define==="function"&&define.amd){define("amazonLocationDataConverter",["exports"],factory)}else if(typeof exports!=="undefined"){factory(exports)}else{var mod={exports:{}};factory(mod.exports);global.amazonLocationDataConverter=mod.exports}})(typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:this,function(_exports2){"use strict";Object.defineProperty(_exports2,"__esModule",{value:true});_exports2.calculateIsolinesResponseToFeatureCollection=calculateIsolinesResponseToFeatureCollection;_exports2.calculateRoutesResponseToFeatureCollections=calculateRoutesResponseToFeatureCollections;_exports2.devicePositionsToFeatureCollection=devicePositionsToFeatureCollection;_exports2.featureCollectionToGeofence=featureCollectionToGeofence;_exports2.geocodeResponseToFeatureCollection=geocodeResponseToFeatureCollection;_exports2.geofencesToFeatureCollection=geofencesToFeatureCollection;_exports2.getPlaceResponseToFeatureCollection=getPlaceResponseToFeatureCollection;_exports2.optimizeWaypointsResponseToFeatureCollection=optimizeWaypointsResponseToFeatureCollection;_exports2.placeToFeatureCollection=placeToFeatureCollection;_exports2.reverseGeocodeResponseToFeatureCollection=reverseGeocodeResponseToFeatureCollection;_exports2.routeToFeatureCollection=routeToFeatureCollection;_exports2.searchNearbyResponseToFeatureCollection=searchNearbyResponseToFeatureCollection;_exports2.searchTextResponseToFeatureCollection=searchTextResponseToFeatureCollection;_exports2.snapToRoadsResponseToFeatureCollection=snapToRoadsResponseToFeatureCollection;_exports2.suggestResponseToFeatureCollection=suggestResponseToFeatureCollection;// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// Third party license at https://github.com/aws-geospatial/amazon-location-utilities-datatypes-js/blob/main/LICENSE-THIRD-PARTY.txt
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * It converts a FeatureCollection with Polygon Features to an array of BatchPutGeofenceRequestEntry, so the result can
 * be used to assemble the request to BatchPutGeofence.
 *
 * It will map the id of the Feature to the `GeofenceId` field of the corresponding entry in the output.
 *
 * If it sees the `Circle` property in a Feature, it will be converted to a Circle Geofence using its `Center` and
 * `Radius` properties instead of a Polygon Geofence.
 *
 * <b>Note</b>: when converting the output of `geofencesToFeatureCollection` function, the following fields will be
 * removed as we can not set them when uploading geofences:
 *
 * 1. Status
 * 2. CreateTime
 * 3. UpdateTime
 *
 * @example Converting a polygon geofence
 *
 * Input:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z"
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           [
 *             [1, 2],
 *             [1, 3],
 *             [2, 3],
 *             [1, 2]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * [{
 *   "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "Geometry": {
 *     "Polygon": [[
 *       [1, 2],
 *       [1, 3],
 *       [2, 3],
 *       [1, 2]
 *     ]]
 *   }
 * }]
 * ```
 *
 * @example Converting a circle geofence
 *
 * Input:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z",
 *         "Circle": {
 *           "Center": [1, 2],
 *           "Radius": 10.0
 *         }
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           // ... approximated Polygon
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * [{
 *   "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "Geometry": {
 *     "Circle": {
 *       "Center": [1, 2],
 *       "Radius": 10.0
 *     }
 *   }
 * }]
 * ```
 */function featureCollectionToGeofence(featureCollection){return featureCollection.features.map(feature=>convertFeatureToGeofence(feature)).filter(entry=>entry)}function convertFeatureToGeofence(feature){var _a,_b;if(feature&&((_a=feature.geometry)===null||_a===void 0?void 0:_a.type)=="Polygon"){if(feature.properties&&"center"in feature.properties){// Circular geofence
return{GeofenceId:String(feature.id),Geometry:{Circle:{Center:feature.properties.center,Radius:feature.properties.radius}}}}else if((_b=feature.geometry)===null||_b===void 0?void 0:_b.coordinates){return{GeofenceId:String(feature.id),Geometry:{Polygon:feature.geometry.coordinates}}}}}/**
 * @module helpers
 *//**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */var earthRadius=6371008.8;/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */var factors={centimeters:earthRadius*100,centimetres:earthRadius*100,degrees:earthRadius/111325,feet:earthRadius*3.28084,inches:earthRadius*39.37,kilometers:earthRadius/1000,kilometres:earthRadius/1000,meters:earthRadius,metres:earthRadius,miles:earthRadius/1609.344,millimeters:earthRadius*1000,millimetres:earthRadius*1000,nauticalmiles:earthRadius/1852,radians:1,yards:earthRadius*1.0936};/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */function feature(geom,properties,options){if(options===void 0){options={}}var feat={type:"Feature"};if(options.id===0||options.id){feat.id=options.id}if(options.bbox){feat.bbox=options.bbox}feat.properties=properties||{};feat.geometry=geom;return feat}/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */function point(coordinates,properties,options){if(options===void 0){options={}}if(!coordinates){throw new Error("coordinates is required")}if(!Array.isArray(coordinates)){throw new Error("coordinates must be an Array")}if(coordinates.length<2){throw new Error("coordinates must be at least 2 numbers long")}if(!isNumber(coordinates[0])||!isNumber(coordinates[1])){throw new Error("coordinates must contain numbers")}var geom={type:"Point",coordinates:coordinates};return feature(geom,properties,options)}/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */function polygon(coordinates,properties,options){if(options===void 0){options={}}for(var _i=0,coordinates_1=coordinates;_i<coordinates_1.length;_i++){var ring=coordinates_1[_i];if(ring.length<4){throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.")}for(var j=0;j<ring[ring.length-1].length;j++){// Check if first point of Polygon contains two numbers
if(ring[ring.length-1][j]!==ring[0][j]){throw new Error("First and last Position are not equivalent.")}}}var geom={type:"Polygon",coordinates:coordinates};return feature(geom,properties,options)}/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */function lengthToRadians(distance,units){if(units===void 0){units="kilometers"}var factor=factors[units];if(!factor){throw new Error(units+" units is invalid")}return distance/factor}/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */function radiansToDegrees(radians){var degrees=radians%(2*Math.PI);return degrees*180/Math.PI}/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */function degreesToRadians(degrees){var radians=degrees%360;return radians*Math.PI/180}/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */function isNumber(num){return!isNaN(num)&&num!==null&&!Array.isArray(num)}/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */function getCoord(coord){if(!coord){throw new Error("coord is required")}if(!Array.isArray(coord)){if(coord.type==="Feature"&&coord.geometry!==null&&coord.geometry.type==="Point"){return coord.geometry.coordinates}if(coord.type==="Point"){return coord.coordinates}}if(Array.isArray(coord)&&coord.length>=2&&!Array.isArray(coord[0])&&!Array.isArray(coord[1])){return coord}throw new Error("coord must be GeoJSON Point or an Array of numbers")}// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in
 * degrees, radians, miles, or kilometers; and bearing in degrees.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Coord} origin starting point
 * @param {number} distance distance from the origin point
 * @param {number} bearing ranging from -180 to 180
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] Translate properties to Point
 * @returns {Feature<Point>} destination point
 * @example
 * var point = turf.point([-75.343, 39.984]);
 * var distance = 50;
 * var bearing = 90;
 * var options = {units: 'miles'};
 *
 * var destination = turf.destination(point, distance, bearing, options);
 *
 * //addToMap
 * var addToMap = [point, destination]
 * destination.properties['marker-color'] = '#f00';
 * point.properties['marker-color'] = '#0f0';
 */function destination(origin,distance,bearing,options){if(options===void 0){options={}}// Handle input
var coordinates1=getCoord(origin);var longitude1=degreesToRadians(coordinates1[0]);var latitude1=degreesToRadians(coordinates1[1]);var bearingRad=degreesToRadians(bearing);var radians=lengthToRadians(distance,options.units);// Main
var latitude2=Math.asin(Math.sin(latitude1)*Math.cos(radians)+Math.cos(latitude1)*Math.sin(radians)*Math.cos(bearingRad));var longitude2=longitude1+Math.atan2(Math.sin(bearingRad)*Math.sin(radians)*Math.cos(latitude1),Math.cos(radians)-Math.sin(latitude1)*Math.sin(latitude2));var lng=radiansToDegrees(longitude2);var lat=radiansToDegrees(latitude2);return point([lng,lat],options.properties)}/**
 * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.
 *
 * @name circle
 * @param {Feature<Point>|number[]} center center point
 * @param {number} radius radius of the circle
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.steps=64] number of steps
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] properties
 * @returns {Feature<Polygon>} circle polygon
 * @example
 * var center = [-75.343, 39.984];
 * var radius = 5;
 * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};
 * var circle = turf.circle(center, radius, options);
 *
 * //addToMap
 * var addToMap = [turf.point(center), circle]
 */function circle(center,radius,options){if(options===void 0){options={}}// default params
var steps=options.steps||64;var properties=options.properties?options.properties:!Array.isArray(center)&&center.type==="Feature"&&center.properties?center.properties:{};// main
var coordinates=[];for(var i=0;i<steps;i++){coordinates.push(destination(center,radius,i*-360/steps,options).geometry.coordinates)}coordinates.push(coordinates[0]);return polygon([coordinates],properties)}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * Converts an array of GeoJSON Features to a FeatureCollection.
 *
 * @param features An array of GeoJSON Features.
 * @returns A GeoJSON FeatureCollection containing provided Features.
 */function toFeatureCollection(features){return{type:"FeatureCollection",features:features?features.filter(feature=>feature):[]}}/**
 * Optionally flatten the Amazon Location Service object.
 *
 * @param obj Amazon Location Service object.
 * @returns Flattened object.
 */function flattenProperties(obj){let prefix=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"";// The following fields are arrays, but should be considered atomic datatypes, not lists of numbers,
// so they shouldn't get flattened.
const doNotFlattenList=[// These are all number[] arrays that represent a coordinate.
"Geometry","Position","Center","BiasPosition","QueryPosition","DeparturePosition","DestinationPosition","StartPosition","EndPosition","Point","SnappedDestination","SnappedOrigin","Destination","Origin","OriginalPosition","SnappedPosition","MapView",// These are number[] arrays that represent the corners of a box.
"BoundingBox","FilterBBox","ResultBBox","RouteBBox",// LineString is a number[][] array containing a list of points that make up a contiguous line
"LineString",// Polygon is a number[][][] array that contains multiple LineStrings representing outer and inner rings
"Polygon"];// If we've ended up in here without a struct or array, something has gone wrong, so just return.
if(typeof obj!=="object"||obj===null){return{}}const result={};// If we're flattening an array, loop through the entries and flatten them to entries that look like
// prefix.0, prefix.1, etc.
if(Array.isArray(obj)){for(const[index,entry]of obj.entries()){// We shouldn't ever have an empty prefix, but just in case we do, just make the key "0", "1", etc.
const newKey=prefix?`${prefix}.${index}`:`${index}`;// Recursively flatten nested objects.
if(typeof entry==="object"&&entry!==null){Object.assign(result,flattenProperties(entry,newKey))}else{result[newKey]=entry}}}else{// If we're flattening a struct, loop through all the properties in the struct and flatten them out.
Object.entries(obj).forEach(_ref=>{let[key,value]=_ref;const newKey=prefix?`${prefix}.${key}`:key;// If we have nested structs or arrays, flatten them unless they're on one of our exception lists.
if(typeof value==="object"&&value!==null){if(doNotFlattenList.includes(key)){// For number[] values that represent a datatype like [lng, lat] instead of a list,
// we'll keep them as-is without flattening.
result[newKey]=value}else{// For every other nested struct or array, recursively flatten it.
Object.assign(result,flattenProperties(value,newKey))}}else{result[newKey]=value}})}return result}function emptyFeatureCollection(){return{type:"FeatureCollection",features:[]}}function convertGeometryToFeature(geometry,properties){if(geometry){const[type,coordinates]=Object.entries(geometry).find((// eslint-disable-next-line @typescript-eslint/no-unused-vars
_ref2)=>{let[_,coordinates]=_ref2;return coordinates!=undefined})||[];switch(type){case"Point":case"LineString":case"Polygon":return{type:"Feature",properties:Object.assign({},properties),geometry:{type,coordinates}};case"Circle":{const{Center:center,Radius:radius}=coordinates;return circle(center,radius,{units:"meters",properties:Object.assign({center,radius},properties)})}}}}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * It converts place responses to a FeatureCollection with Point Features. It converts
 *
 * 1. GetPlaceResponse to a FeatureCollection with a single feature.
 * 2. SearchPlaceIndexForPositionResponse, SearchPlaceIndexForTextResponse to a FeatureCollection with features
 *    corresponding to the entries in the response.
 *
 * `PlaceId` will be mapped to the `id` of the output Feature if `PlaceId` is provided. Fields other than `Geometry` in
 * a place will be mapped into the properties of the corresponding Feature.
 *
 * Any place without the `Point` field will be skipped.
 *
 * @example Drawing the result of SearchPlaceIndexForText with MapLibre could be simplified with this converter from the
 * below code:
 *
 * ```js
 * // ...
 * location.searchPlaceIndexForText(params, (err, result) => {
 *   if (err) {
 *     // error handling
 *   } else {
 *     const featureCollection = {
 *       type: "FeatureCollection",
 *       features:
 *         result?.Results?.map((result) => {
 *           return {
 *             type: "Feature",
 *             geometry: {
 *               type: "Point",
 *               properties: {}, // translate the properties here
 *               coordinates: result?.Place?.Geometry?.Point,
 *             },
 *           };
 *         }) || [],
 *     };
 *     map.addSource("search-result", featureCollection);
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * });
 * // ...
 * ```
 *
 * To:
 *
 * ```js
 * // ...
 * location.searchPlaceIndexForText(params, (err, result) => {
 *   if (err) {
 *     // error handling
 *   } else {
 *     const featureCollection = placeToFeatureCollection(result);
 *     map.addSource("search-result", featureCollection);
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * });
 * // ...
 * ```
 *
 * @example Converting a GetPlace result
 *
 * Result of GetPlace:
 *
 * ```json
 * {
 *   "Place": {
 *     "Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC, V6G 1C8, CAN",
 *     "Geometry": {
 *       "Point": [-123.13, 49.28]
 *     },
 *     "AddressNumber": "1675",
 *     "Street": "Robson St",
 *     "Municipality": "Vancouver",
 *     "SubRegion": "Greater Vancouver",
 *     "Region": "British Columbia",
 *     "Country": "CAN",
 *     "PostalCode": "V6G 1C8",
 *     "Interpolated": false
 *   }
 * }
 * ```
 *
 * Output flattenProperties is false:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "Place": {
 *           "Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC, V6G 1C8, CAN",
 *           "AddressNumber": "1675",
 *           "Street": "Robson St",
 *           "Municipality": "Vancouver",
 *           "SubRegion": "Greater Vancouver",
 *           "Region": "British Columbia",
 *           "Country": "CAN",
 *           "PostalCode": "V6G 1C8",
 *           "Interpolated": false
 *         }
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-123.13, 49.28]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * - Output flattenProperties is true:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "Place.Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC, V6G 1C8, CAN",
 *         "Place.AddressNumber": "1675",
 *         "Place.Street": "Robson St",
 *         "Place.Municipality": "Vancouver",
 *         "Place.SubRegion": "Greater Vancouver",
 *         "Place.Region": "British Columbia",
 *         "Place.Country": "CAN",
 *         "Place.PostalCode": "V6G 1C8",
 *         "Place.Interpolated": false
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-123.13, 49.28]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a SearchPlaceIndexForTextResponse result with the second result missing the `Point` field
 *
 * Result of SearchPlaceIndexForTextResponse:
 *
 * ```json
 * {
 *   "Summary": {
 *     "Text": "whole foods",
 *     "BiasPosition": [-123.115, 49.295],
 *     "MaxResults": 2,
 *     "DataSource": "Here"
 *   },
 *   "Results": [
 *     {
 *       "Place": {
 *         "Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC V6G 1C8, Canada",
 *         "Geometry": {
 *           "Point": [-123.132, 49.29]
 *         },
 *         "AddressNumber": "1675",
 *         "Street": "Robson St",
 *         "Neighborhood": "West End",
 *         "Municipality": "Vancouver",
 *         "SubRegion": "Metro Vancouver",
 *         "Region": "British Columbia",
 *         "Country": "CAN",
 *         "PostalCode": "V6G 1C8",
 *         "Interpolated": false,
 *         "TimeZone": {
 *           "Name": "America/Vancouver",
 *           "Offset": -25200
 *         }
 *       },
 *       "Distance": 1385.945532454018,
 *       "PlaceId": "AQAAAHAArZ9I7WtFD"
 *     },
 *     {
 *       "Place": {
 *         "Label": "Whole Foods Market, 510 W 8th Ave, Vancouver, BC V5Z 1C5, Canada",
 *         "Geometry": {}
 *       },
 *       "PlaceId": "AQAAAHAA0gZK0c"
 *     },
 *     {
 *       "Place": {
 *         "Label": "Whole Foods, 925 Main St, West Vancouver, BC V7T, Canada",
 *         "Geometry": {
 *           "Point": [-123.142, 49.325]
 *         },
 *         "AddressNumber": "925",
 *         "Street": "Main St",
 *         "Neighborhood": "Capilano Indian Reserve 5",
 *         "Municipality": "West Vancouver",
 *         "SubRegion": "Metro Vancouver",
 *         "Region": "British Columbia",
 *         "Country": "CAN",
 *         "PostalCode": "V7T",
 *         "Interpolated": false,
 *         "TimeZone": {
 *           "Name": "America/Vancouver",
 *           "Offset": -25200
 *         }
 *       },
 *       "Distance": 3876.5708436735226,
 *       "PlaceId": "AQAAAHAAo5aDp0fMX"
 *     }
 *   ]
 * }
 * ```
 *
 * Output flattenProperties is true:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "AQAAAHAArZ9I7WtFD",
 *       "properties": {
 *          "Distance": 1385.945532454018
 *          "Place.Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC V6G 1C8, Canada",
 *          "Place.AddressNumber": "1675",
 *          "Place.Street": "Robson St",
 *          "Place.Neighborhood": "West End",
 *          "Place.Municipality": "Vancouver",
 *          "Place.SubRegion": "Metro Vancouver",
 *          "Place.Region": "British Columbia",
 *          "Place.Country": "CAN",
 *          "Place.PostalCode": "V6G 1C8",
 *          "Place.Interpolated": false,
 *          "Place.TimeZone.Name": "America/Vancouver",
 *          "Place.TimeZone.Offset": -25200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-123.132, 49.29]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "id": "AQAAAHAAo5aDp0fMX",
 *       "properties": {
 *          "Distance": 3876.5708436735226
 *          "Place.Label": "Whole Foods, 925 Main St, West Vancouver, BC V7T, Canada",
 *          "Place.AddressNumber": "925",
 *          "Place.Street": "Main St",
 *          "Place.Neighborhood": "Capilano Indian Reserve 5",
 *          "Place.Municipality": "West Vancouver",
 *          "Place.SubRegion": "Metro Vancouver",
 *          "Place.Region": "British Columbia",
 *          "Place.Country": "CAN",
 *          "Place.PostalCode": "V7T",
 *          "Place.Interpolated": false,
 *          "Place.TimeZone.Name": "America/Vancouver",
 *          "Place.TimeZone.Offset": -25200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-123.142, 49.325]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @param place Response of the GetPlace or SearchPlace* API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 */function placeToFeatureCollection(place,options){if("Results"in place){const features=place.Results.map(result=>result&&convertPlaceToFeature(result,options));return toFeatureCollection(features)}else if("Place"in place){const features=[convertPlaceToFeature(place,options)];return toFeatureCollection(features)}else{return emptyFeatureCollection()}}/**
 * Convert an Amazon Location Place object to a GeoJSON Feature.
 *
 * @param place The Place object from Amazon Location SDK.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON Feature of the Place object, or null if there isn't the Geometry.Point property present.
 */function convertPlaceToFeature(place,options){var _a,_b,_c;const coordinates=(_b=(_a=place.Place)===null||_a===void 0?void 0:_a.Geometry)===null||_b===void 0?void 0:_b.Point;if(coordinates){const placeClone=Object.assign({},place);(_c=placeClone.Place)===null||_c===void 0?true:delete _c.Geometry;delete placeClone["$metadata"];const properties=(options===null||options===void 0?void 0:options.flattenProperties)?flattenProperties(Object.assign({},placeClone)):Object.assign({},placeClone);return{type:"Feature",id:"PlaceId"in place?place.PlaceId:undefined,properties:properties,geometry:{type:"Point",coordinates:coordinates}}}return null}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __rest$2=undefined&&undefined.__rest||function(s,e){var t={};for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0)t[p]=s[p];if(s!=null&&typeof Object.getOwnPropertySymbols==="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++){if(e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i]))t[p[i]]=s[p[i]]}return t};const defaultBaseGeoPlacesOptions={flattenProperties:true};const defaultGetPlaceResponseOptions=defaultBaseGeoPlacesOptions;/**
 * Convert GetPlaceResponse responses from our standalone Places SDK to a FeatureCollection with a Point Feature. Each
 * Feature is given a locally-unique integer id for easier use with MapLibre. `Position` is extracted as the location
 * for the Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If the result doesn't contain location information, the output will be an empty FeatureCollection.
 *
 * @example Drawing the result of GetPlaceCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.GetPlaceCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.getPlaceResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response GetPlaceResponse from the GetPlace API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */function getPlaceResponseToFeatureCollection(response,options){// Set any options that weren't passed in to the defaults.
options=Object.assign(Object.assign({},defaultGetPlaceResponseOptions),options);const collection=emptyFeatureCollection();// Create a single feature in the feature collection with the entire response in the properties except
// for Position, since that becomes the feature's geometry coordinates.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const properties=__rest$2(response,["Position"]);addGeoJsonPointFeature(collection,response.Position,properties,options.flattenProperties);return collection}const defaultGeocodeResponseOptions=defaultBaseGeoPlacesOptions;/**
 * Convert GeocodeResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features. Each
 * item in the `ResultItems` list is extracted as its own feature. `Position` is extracted as the location for the Point
 * Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of GeocodeCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.GeocodeCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.geocodeResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response GeocodeResponse from the Geocode API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */function geocodeResponseToFeatureCollection(response,options){var _a;// Set any options that weren't passed in to the defaults.
options=Object.assign(Object.assign({},defaultGeocodeResponseOptions),options);const collection=emptyFeatureCollection();for(const result of(_a=response.ResultItems)!==null&&_a!==void 0?_a:[]){// Create a single feature in the feature collection for each result with the entire result in the properties except
// for Position, since that becomes the feature's geometry coordinates.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const properties=__rest$2(result,["Position"]);addGeoJsonPointFeature(collection,result.Position,properties,options.flattenProperties)}return collection}const defaultReverseGeocodeResponseOptions=defaultBaseGeoPlacesOptions;/**
 * Convert ReverseGeocodeResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features.
 * Each item in the `ResultItems` list is extracted as its own feature. `Position` is extracted as the location for the
 * Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of ReverseGeocodeCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.ReverseGeocodeCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.reverseGeocodeResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response ReverseGeocodeResponse from the ReverseGeocode API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */function reverseGeocodeResponseToFeatureCollection(response,options){var _a;// Set any options that weren't passed in to the defaults.
options=Object.assign(Object.assign({},defaultReverseGeocodeResponseOptions),options);const collection=emptyFeatureCollection();for(const result of(_a=response.ResultItems)!==null&&_a!==void 0?_a:[]){// Create a single feature in the feature collection for each result with the entire result in the properties except
// for Position, since that becomes the feature's geometry coordinates.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const properties=__rest$2(result,["Position"]);addGeoJsonPointFeature(collection,result.Position,properties,options.flattenProperties)}return collection}const defaultSearchNearbyResponseOptions=defaultBaseGeoPlacesOptions;/**
 * Convert SearchNearbyResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features.
 * Each item in the `ResultItems` list is extracted as its own feature. `Position` is extracted as the location for the
 * Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of SearchNearbyCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.SearchNearbyCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.searchNearbyResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response SearchNearbyResponse from the SearchNearby API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */function searchNearbyResponseToFeatureCollection(response,options){var _a;// Set any options that weren't passed in to the defaults.
options=Object.assign(Object.assign({},defaultSearchNearbyResponseOptions),options);const collection=emptyFeatureCollection();for(const result of(_a=response.ResultItems)!==null&&_a!==void 0?_a:[]){// Create a single feature in the feature collection for each result with the entire result in the properties except
// for Position, since that becomes the feature's geometry coordinates.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const properties=__rest$2(result,["Position"]);addGeoJsonPointFeature(collection,result.Position,properties,options.flattenProperties)}return collection}const defaultSearchTextResponseOptions=defaultBaseGeoPlacesOptions;/**
 * Convert SearchTextResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features.
 * Each item in the `ResultItems` list is extracted as its own feature. `Position` is extracted as the location for the
 * Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of SearchTextCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.SearchTextCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.searchTextResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response SearchTextResponse from the SearchText API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */function searchTextResponseToFeatureCollection(response,options){var _a;// Set any options that weren't passed in to the defaults.
options=Object.assign(Object.assign({},defaultSearchTextResponseOptions),options);const collection=emptyFeatureCollection();for(const result of(_a=response.ResultItems)!==null&&_a!==void 0?_a:[]){// Create a single feature in the feature collection for each result with the entire result in the properties except
// for Position, since that becomes the feature's geometry coordinates.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const properties=__rest$2(result,["Position"]);addGeoJsonPointFeature(collection,result.Position,properties,options.flattenProperties)}return collection}const defaultSuggestResponseOptions=defaultBaseGeoPlacesOptions;/**
 * Convert SuggestResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features. Each
 * item in the `ResultItems` list is extracted as its own feature. `Place.Position` is extracted as the location for the
 * Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of SuggestCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.SuggestCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.suggestResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response SuggestResponse from the SearchText API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */function suggestResponseToFeatureCollection(response,options){var _a,_b,_c;// Set any options that weren't passed in to the defaults.
options=Object.assign(Object.assign({},defaultSuggestResponseOptions),options);const collection=emptyFeatureCollection();for(const result of(_a=response.ResultItems)!==null&&_a!==void 0?_a:[]){// Create a single feature in the feature collection for each result with the entire result in the properties except
// for Place.Position, since that becomes the feature's geometry coordinates.
// We use structuredClone here to make a deep copy to ensure that deleting from the nested
// Place struct doesn't change the original value.
const properties=structuredClone(result);(_b=properties.Place)===null||_b===void 0?true:delete _b.Position;addGeoJsonPointFeature(collection,(_c=result.Place)===null||_c===void 0?void 0:_c.Position,properties,options.flattenProperties)}return collection}/**
 * Creates a GeoJSON feature from a given id, coordinates, and Response structure.
 *
 * @param collection The FeatureCollection to add the feature to.
 * @param coordinates The coordinates to use for the Point, extracted from the Response structure.
 * @param properties The Response structure with the placeId and coordinates removed from it. The placeId and
 *   coordinates are expected to be removed because they would be redundant data since they already appear as the id and
 *   the geometry coordinates of the Point Feature.
 * @param flatten Whether to flatten the properties or not. Defaults to true.
 * @returns A GeoJSON Point Feature of the Response object, or null if no coordinates were present.
 */function addGeoJsonPointFeature(collection,coordinates,properties,flatten){if(coordinates){// Create a shallow copy of the passed-in properties and remove "$metadata", which can appear
// in Response objects from the AWS SDK. Since $metadata is only metadata about the API call and
// not a part of the Response data, we don't want or need it to appear in the generated GeoJSON.
const propertiesClone=Object.assign({},properties);delete propertiesClone["$metadata"];collection.features.push({type:"Feature",id:collection.features.length,properties:flatten?flattenProperties(propertiesClone):propertiesClone,geometry:{type:"Point",coordinates:coordinates}})}}var commonjsGlobal=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof global!=="undefined"?global:typeof self!=="undefined"?self:{};var polyline={};(function(exports){(function(global,factory){{factory(exports)}})(typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:commonjsGlobal,function(_exports){Object.defineProperty(_exports,"__esModule",{value:true});_exports.ThirdDimension=_exports.CompressionAlgorithm=void 0;_exports.decodeToLineString=decodeToLineString;_exports.decodeToLineStringFeature=decodeToLineStringFeature;_exports.decodeToLngLatArray=decodeToLngLatArray;_exports.decodeToPolygon=decodeToPolygon;_exports.decodeToPolygonFeature=decodeToPolygonFeature;_exports.encodeFromLngLatArray=encodeFromLngLatArray;_exports.getCompressionAlgorithm=getCompressionAlgorithm;_exports.setCompressionAlgorithm=setCompressionAlgorithm;function _callSuper(t,o,e){return o=_getPrototypeOf(o),_possibleConstructorReturn(t,_isNativeReflectConstruct()?Reflect.construct(o,e||[],_getPrototypeOf(t).constructor):o.apply(t,e))}function _possibleConstructorReturn(t,e){if(e&&("object"==_typeof(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(t)}function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(t){}return(_isNativeReflectConstruct=function _isNativeReflectConstruct(){return!!t})()}function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_setPrototypeOf(t,e)}function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=_unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var _n=0,F=function F(){};return{s:F,n:function n(){return _n>=r.length?{done:!0}:{done:!1,value:r[_n++]}},e:function e(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function s(){t=t.call(r)},n:function n(){var r=t.next();return a=r.done,r},e:function e(r){u=!0,o=r},f:function f(){try{a||null==t["return"]||t["return"]()}finally{if(u)throw o}}}}function _slicedToArray(r,e){return _arrayWithHoles(r)||_iterableToArrayLimit(r,e)||_unsupportedIterableToArray(r,e)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return _arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(r,a):void 0}}function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t["return"]&&(u=t["return"](),Object(u)!==u))return}finally{if(o)throw n}}return a}}function _arrayWithHoles(r){if(Array.isArray(r))return r}function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,_toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}function _toPropertyKey(t){var i=_toPrimitive(t,"string");return"symbol"==_typeof(i)?i:i+""}function _toPrimitive(t,r){if("object"!=_typeof(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// Third party license at
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
/** Defines the default encoding precision for coordinates */var DefaultPrecision=6;/** The version of flexible-polyline that's supported by this implementation */var FlexiblePolylineFormatVersion=1;/** Defines the set of compression algorithms that are supported by this library. */var CompressionAlgorithm;(function(CompressionAlgorithm){/** Encoder/decoder for the [Flexible Polyline](https://github.com/heremaps/flexible-polyline) format. */CompressionAlgorithm[CompressionAlgorithm["FlexiblePolyline"]=0]="FlexiblePolyline";/** Encoder/decoder for the [Encoded Polyline Algorithm Format](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
	     * with 5 bits of precision.
	     */CompressionAlgorithm[CompressionAlgorithm["Polyline5"]=1]="Polyline5";/** Encoder/decoder for the [Encoded Polyline Algorithm Format](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
	     * with 6 bits of precision.
	     */CompressionAlgorithm[CompressionAlgorithm["Polyline6"]=2]="Polyline6"})(CompressionAlgorithm||(_exports.CompressionAlgorithm=CompressionAlgorithm={}));/** Defines how to interpret a third dimension value if it exists. */var ThirdDimension;(function(ThirdDimension){/** No third dimension specified */ThirdDimension[ThirdDimension["None"]=0]="None";/** Third dimension is level */ThirdDimension[ThirdDimension["Level"]=1]="Level";/** Third dimension is altitude (height above the Earth's surface) */ThirdDimension[ThirdDimension["Altitude"]=2]="Altitude";/** Third dimension is elevation (height of the Earth's surface relative to the reference geoid) */ThirdDimension[ThirdDimension["Elevation"]=3]="Elevation"})(ThirdDimension||(_exports.ThirdDimension=ThirdDimension={}));// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// DataCompressor is an abstract base class that defines the interface for
// encoding/decoding compressed coordinate arrays. The coordinate arrays represent either
// LineString ("polyline") or Polygon geometry.
// To make this compressed data easy to use with MapLibre, DataCompressor provides
// methods for decoding the data into different types of GeoJSON outputs:
//  - decodeToLineStringFeature / decodeToPolygonFeature:
//      These produce a GeoJSON Feature object that can be directly passed into MapLibre as a geojson source.
//  - decodeToLineString / decodeToPolygon:
//      These produce a GeoJSON Geometry object that can be manually assembled into a Feature to pass
//      into MapLibre as a geojson source.
// Concrete implementations of this class are expected to implement the following APIs:
// - compressLngLatArray(lngLatArray, compressionParameters) -> compressedData
// - decompressLngLatArray(compressedData) -> [lngLatArray, compressionParameters]
var DataCompressor=/*#__PURE__*/function(){function DataCompressor(){_classCallCheck(this,DataCompressor)}return _createClass(DataCompressor,[{key:"polygonIsCounterClockwise",value:// Helper method to determine whether the polygon is wound in CCW (counterclockwise) or CW (clockwise) order.
function polygonIsCounterClockwise(lngLatArray){// If the data isn't a polygon, then it can't be a counter-clockwise polygon.
// (A polygon requires at least 3 unique points and a 4th last point that matches the first)
if(lngLatArray.length<4){return false}// To determine if a polygon has a counterclockwise winding order, all we need to
// do is calculate the area of the polygon.
// If the area is positive, it's counterclockwise.
// If the area is negative, it's clockwise.
// If the area is 0, it's neither, so we'll still return false for counterclockwise.
// This implementation currently assumes that only 2D winding order is important and
// ignores any optional third dimension.
var area=0;for(var idx=0;idx<lngLatArray.length-1;idx++){var x1=lngLatArray[idx][0];var y1=lngLatArray[idx][1];var x2=lngLatArray[idx+1][0];var y2=lngLatArray[idx+1][1];area+=x1*y2-x2*y1}// If we needed the actual area value, we should divide by 2 here, but since we only
// need to check the sign, we can skip the division.
return area>0}// Helper method to determine if two LngLat positions are equivalent within a given epsilon range.
},{key:"positionsAreEquivalent",value:function positionsAreEquivalent(pos1,pos2){// Verify that the two positions are equal within an epsilon.
// This epsilon was picked because most compressed data uses <= 6 digits of precision,
// so this epsilon is large enough to detect intentionally different data, and small
// enough to detect equivalency for values that just have compression artifact drift.
var epsilon=0.000001;if(pos1.length!=pos2.length){return false}// Loop through longitude, latitude, and optional 3rd dimension to make sure each one is equivalent.
for(var idx=0;idx<pos1.length;idx++){if(Math.abs(pos1[idx]-pos2[idx])>=epsilon){return false}}return true}},{key:"decodeLineString",value:function decodeLineString(compressedData){var _this$decompressLngLa=this.decompressLngLatArray(compressedData),_this$decompressLngLa2=_slicedToArray(_this$decompressLngLa,2),decodedLine=_this$decompressLngLa2[0],compressionParameters=_this$decompressLngLa2[1];// Validate that the result is a valid GeoJSON LineString per the RFC 7946 GeoJSON spec:
// "The 'coordinates' member is an array of two or more positions"
if(decodedLine.length<2){throw Error("Invalid LineString. LineStrings must contain 2 or more positions. It contains ".concat(decodedLine.length," positions."))}return[{type:"LineString",coordinates:decodedLine},compressionParameters]}},{key:"decodePolygon",value:function decodePolygon(compressedData){var decodedPolygon=[];var shouldBeCounterclockwise=true;// The first ring of a polygon should be counterclockwise
var compressionParameters={};var _iterator=_createForOfIteratorHelper(compressedData),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var ring=_step.value;var _this$decompressLngLa3=this.decompressLngLatArray(ring),_this$decompressLngLa4=_slicedToArray(_this$decompressLngLa3,2),decodedRing=_this$decompressLngLa4[0],ringCompressionParameters=_this$decompressLngLa4[1];// Validate that the result is a valid GeoJSON Polygon linear ring per the RFC 7946 GeoJSON spec.
// 1. "A linear ring is a closed LineString with 4 or more positions."
if(decodedRing.length<4){throw Error("Invalid polygon. Polygons must contain 4 or more positions. It contains ".concat(decodedRing.length," positions. Consider decoding as a LineString."))}// 2. "The first and last positions are equivalent, and they MUST contain identical values;
//     their representation SHOULD also be identical."
// We validate equivalency within a small epsilon.
if(!this.positionsAreEquivalent(decodedRing[0],decodedRing[decodedRing.length-1])){throw Error("Invalid polygon. The first and last positions must contain identical values. The values are ".concat(decodedRing[0],", ").concat(decodedRing.at(-1),". Consider decoding as a LineString."))}// 3. "A linear ring MUST follow the right-hand rule with respect to the area it bounds,
//     i.e., exterior rings are counterclockwise, and holes are clockwise."
// "Note: the [GJ2008] specification did not discuss linear ring winding
//    order.  For backwards compatibility, parsers SHOULD NOT reject
//    Polygons that do not follow the right-hand rule."
// "For Polygons with more than one of these rings, the first MUST be
//       the exterior ring, and any others MUST be interior rings.  The
//       exterior ring bounds the surface, and the interior rings (if
//       present) bound holes within the surface."
// With all this taken together, we should enforce the winding order as opposed to just
// validating it.
if(shouldBeCounterclockwise!=this.polygonIsCounterClockwise(decodedRing)){decodedRing.reverse()}decodedPolygon.push(decodedRing);// Set compressionParameter metadata to whatever the last compression parameters were that were used.
// This may need to have more complicated logic at some point if different rings have different compression
// parameters and we want to capture all of them.
compressionParameters=ringCompressionParameters;// All rings after the first should be clockwise.
shouldBeCounterclockwise=false}}catch(err){_iterator.e(err)}finally{_iterator.f()}return[{type:"Polygon",coordinates:decodedPolygon},compressionParameters]}},{key:"compressionParametersToGeoJsonProperties",value:function compressionParametersToGeoJsonProperties(parameters){switch(parameters.thirdDimension){case ThirdDimension.Level:return{precision:parameters.precisionLngLat,thirdDimensionPrecision:parameters.precisionThirdDimension,thirdDimensionType:"level"};case ThirdDimension.Elevation:return{precision:parameters.precisionLngLat,thirdDimensionPrecision:parameters.precisionThirdDimension,thirdDimensionType:"elevation"};case ThirdDimension.Altitude:return{precision:parameters.precisionLngLat,thirdDimensionPrecision:parameters.precisionThirdDimension,thirdDimensionType:"altitude"};default:return{precision:parameters.precisionLngLat}}}},{key:"encodeFromLngLatArray",value:function encodeFromLngLatArray(lngLatArray,parameters){return this.compressLngLatArray(lngLatArray,parameters)}},{key:"decodeToLngLatArray",value:function decodeToLngLatArray(compressedData){var _this$decompressLngLa5=this.decompressLngLatArray(compressedData),_this$decompressLngLa6=_slicedToArray(_this$decompressLngLa5,1),decodedLngLatArray=_this$decompressLngLa6[0];return decodedLngLatArray}},{key:"decodeToLineString",value:function decodeToLineString(compressedData){var _this$decodeLineStrin=this.decodeLineString(compressedData),_this$decodeLineStrin2=_slicedToArray(_this$decodeLineStrin,1),lineString=_this$decodeLineStrin2[0];return lineString}},{key:"decodeToPolygon",value:function decodeToPolygon(compressedData){var _this$decodePolygon=this.decodePolygon(compressedData),_this$decodePolygon2=_slicedToArray(_this$decodePolygon,1),polygon=_this$decodePolygon2[0];return polygon}},{key:"decodeToLineStringFeature",value:function decodeToLineStringFeature(compressedData){var _this$decodeLineStrin3=this.decodeLineString(compressedData),_this$decodeLineStrin4=_slicedToArray(_this$decodeLineStrin3,2),lineString=_this$decodeLineStrin4[0],compressionParameters=_this$decodeLineStrin4[1];return{type:"Feature",geometry:lineString,properties:this.compressionParametersToGeoJsonProperties(compressionParameters)}}},{key:"decodeToPolygonFeature",value:function decodeToPolygonFeature(compressedData){var _this$decodePolygon3=this.decodePolygon(compressedData),_this$decodePolygon4=_slicedToArray(_this$decodePolygon3,2),polygon=_this$decodePolygon4[0],compressionParameters=_this$decodePolygon4[1];return{type:"Feature",geometry:polygon,properties:this.compressionParametersToGeoJsonProperties(compressionParameters)}}}])}();// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// This class implements both the Encoded Polyline Algorithm Format
// (https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
// and the Flexible-Polyline variation of the algorithm (https://github.com/heremaps/flexible-polyline).
// This implementation has two differences to improve usability:
// - It uses well-defined rounding to ensure deterministic results across all programming languages.
//   The Flexible-Polyline algorithm definition says to use the rounding rules of the programming
//   language, but this can cause inconsistent rounding depending on what language happens to be used
//   on both the encoding and decoding sides.
// - It caps the max encoding/decoding precision to 11 decimal places (1 micrometer), because 12+ places can
//   lose precision when using 64-bit floating-point numbers to store integers.
var PolylineEncoder=/*#__PURE__*/function(){function PolylineEncoder(encodingTable,includeHeader){_classCallCheck(this,PolylineEncoder);this.encodingTable=encodingTable;this.includeHeader=includeHeader}// The original polyline algorithm supposedly uses "round to nearest, ties away from 0"
// for its rounding rule. Flexible-polyline uses the rounding rules of the implementing
// language. Our generalized implementation will use the "round to nearest, ties away from 0"
// rule for all languages to keep the encoding deterministic across implementations.
return _createClass(PolylineEncoder,[{key:"polylineRound",value:function polylineRound(value){return Math.sign(value)*Math.floor(Math.abs(value)+0.5)}},{key:"encode",value:function encode(lngLatArray,precision){var _this=this;var thirdDim=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ThirdDimension.None;var thirdDimPrecision=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;if(precision<0||precision>11){throw Error("Only precision values of 0-11 decimal digits are supported.")}if(!Object.values(ThirdDimension).includes(+thirdDim)){throw Error("thirdDim is an invalid ThirdDimension value.")}if(thirdDimPrecision<0||thirdDimPrecision>11){throw Error("Only thirdDimPrecision values of 0-11 decimal digits are supported.")}if(!lngLatArray.length){return""}var numDimensions=thirdDim?3:2;// The data will either encode lat/lng or lat/lng/z values.
// precisionMultipliers are the multipliers needed to convert the values
// from floating-point to scaled integers.
var precisionMultipliers=[Math.pow(10,precision),Math.pow(10,precision),Math.pow(10,thirdDimPrecision)];// While encoding, we want to switch from lng/lat/z to lat/lng/z, so this index tells us
// what index to grab from the input coordinate when encoding each dimension.
var inputDimensionIndex=[1,0,2];// maxAllowedValues are the maximum absolute values allowed for lat/lng/z. This is used for
// error-checking the coordinate values as they're being encoded.
var maxAllowedValues=[90,180,Infinity];// Encoded values are deltas from the previous coordinate values, so track the previous lat/lng/z values.
var lastScaledCoordinate=[0,0,0];var output="";// Flexible-polyline starts with an encoded header that contains precision and dimension metadata.
if(this.includeHeader){output=this.encodeHeader(precision,thirdDim,thirdDimPrecision)}lngLatArray.forEach(function(coordinate){if(coordinate.length!=numDimensions){throw Error("Invalid input. All coordinates need to have the same number of dimensions.")}for(var dimension=0;dimension<numDimensions;dimension++){// Even though our input data is in lng/lat/z order, this is where we grab them in
// lat/lng/z order for encoding.
var inputValue=coordinate[inputDimensionIndex[dimension]];// While looping through, also verify the input data is valid
if(Math.abs(inputValue)>maxAllowedValues[dimension]){throw Error("Invalid input. Input coordinates must contain valid lng/lat coordinate data. Found ".concat(coordinate,"."))}// Scale the value based on the number of digits of precision, encode the delta between
// it and the previous value to the output, and track it as the previous value for encoding
// the next delta.
var scaledValue=_this.polylineRound(inputValue*precisionMultipliers[dimension]);output+=_this.encodeSignedValue(scaledValue-lastScaledCoordinate[dimension]);lastScaledCoordinate[dimension]=scaledValue}});return output}},{key:"encodeHeader",value:function encodeHeader(precision,thirdDim,thirdDimPrecision){// Combine all the metadata about the encoded data into a single value for the header.
var metadataValue=thirdDimPrecision<<7|thirdDim<<4|precision;return this.encodeUnsignedValue(FlexiblePolylineFormatVersion)+this.encodeUnsignedValue(metadataValue)}// Given a single input unsigned scaled value, this encodes into a series of
// ASCII characters. The flexible-polyline algorithm uses this directly to encode
// the header bytes, since those are known not to need a sign bit.
},{key:"encodeUnsignedValue",value:function encodeUnsignedValue(value){var encodedString="";var remainingValue=value;// Loop through each 5-bit chunk in the value, add a 6th bit if there
// will be additional chunks, and encode to an ASCII value.
while(remainingValue>31){var chunk=remainingValue&31|32;encodedString+=this.encodingTable[chunk];remainingValue>>=5}// For the last chunk, set the 6th bit to 0 (since there are no more chunks) and encode it.
return encodedString+this.encodingTable[remainingValue]}// Given a single input signed scaled value, this encodes into a series of
// ASCII characters.
},{key:"encodeSignedValue",value:function encodeSignedValue(value){var unsignedValue=value;// Shift the value over by 1 bit to make room for the sign bit at the end.
unsignedValue<<=1;// If the input value is negative, flip all the bits, including the sign bit.
if(value<0){unsignedValue=~unsignedValue}return this.encodeUnsignedValue(unsignedValue)}}])}();// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// This class implements both the Encoded Polyline Algorithm Format
// (https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
// and the Flexible-Polyline variation of the algorithm (https://github.com/heremaps/flexible-polyline).
// This implementation has two differences to improve usability:
// - It uses well-defined rounding to ensure deterministic results across all programming languages.
// - It caps the max encoding/decoding precision to 11 decimal places (1 micrometer), because 15 places will
//   lose precision when using 64-bit floating-point numbers.
var PolylineDecoder=/*#__PURE__*/function(){function PolylineDecoder(decodingTable,containsHeader){_classCallCheck(this,PolylineDecoder);this.decodingTable=decodingTable;this.containsHeader=containsHeader}// Given an encoded string and a starting index, this decodes a single encoded signed value.
// The decoded value will be an integer that still needs the decimal place moved over based
// on the number of digits of encoded precision.
return _createClass(PolylineDecoder,[{key:"decodeSignedValue",value:function decodeSignedValue(encoded,startIndex){// decode an unsigned value
var _this$decodeUnsignedV=this.decodeUnsignedValue(encoded,startIndex),_this$decodeUnsignedV2=_slicedToArray(_this$decodeUnsignedV,2),unsignedValue=_this$decodeUnsignedV2[0],nextIndex=_this$decodeUnsignedV2[1];// If the unsigned value has a 1 encoded in its least significant bit,
// it's negative, so flip the bits.
var signedValue=unsignedValue;if(unsignedValue&1){signedValue=~signedValue}// Shift the result by one to remove the encoded sign bit.
signedValue>>=1;return[signedValue,nextIndex]}// Given an encoded string and a starting index, this decodes a single encoded
// unsigned value. The flexible-polyline algorithm uses this directly to decode
// the header bytes, since those are encoded without the sign bit as the header
// values are known to be unsigned (which saves 2 bits).
},{key:"decodeUnsignedValue",value:function decodeUnsignedValue(encoded,startIndex){var result=0;var shift=0;var index=startIndex;// For each ASCII character, get the 6-bit (0x00 - 0x3F) value that
// it represents. Shift the accumulated result by 5 bits, add the new
// 5-bit chunk to the bottom, and keep going for as long as the 6th bit
// is set.
while(index<encoded.length){var charCode=encoded.charCodeAt(index);var value=this.decodingTable[charCode];if(value<0){throw Error("Invalid input. Encoded character '".concat(charCode,"' doesn't exist in the decoding table."))}result|=(value&31)<<shift;shift+=5;index++;// We've reached the final 5-bit chunk for this value, so return.
// We also return the index, which represents the starting index of the
// next value to decode.
if((value&32)===0){return[result,index]}}// If we've run out of encoded characters without finding an empty 6th bit,
// something has gone wrong.
throw Error("Invalid encoding - last block contained an extra 0x20 'continue' bit.")}},{key:"decodeHeader",value:function decodeHeader(encoded){// If the data has a header, the first value is expected to be the header version
// and the second value is compressed metadata containing precision and dimension information.
var _this$decodeUnsignedV3=this.decodeUnsignedValue(encoded,0),_this$decodeUnsignedV4=_slicedToArray(_this$decodeUnsignedV3,2),headerVersion=_this$decodeUnsignedV4[0],metadataIndex=_this$decodeUnsignedV4[1];if(headerVersion!==FlexiblePolylineFormatVersion){throw new Error("Invalid format version")}var _this$decodeUnsignedV5=this.decodeUnsignedValue(encoded,metadataIndex),_this$decodeUnsignedV6=_slicedToArray(_this$decodeUnsignedV5,2),metadata=_this$decodeUnsignedV6[0],nextIndex=_this$decodeUnsignedV6[1];return[{precisionLngLat:metadata&15,thirdDimension:metadata>>4&7,precisionThirdDimension:metadata>>7&15},nextIndex]}},{key:"decode",value:function decode(encoded){var encodePrecision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;// If the data doesn't have a header, default to the passed-in precision and no 3rd dimension.
var header={precisionLngLat:encodePrecision,thirdDimension:ThirdDimension.None,precisionThirdDimension:0};// Track the index of the next character to decode from the encoded string.
var index=0;if(this.containsHeader){var _this$decodeHeader=this.decodeHeader(encoded);var _this$decodeHeader2=_slicedToArray(_this$decodeHeader,2);header=_this$decodeHeader2[0];index=_this$decodeHeader2[1]}var numDimensions=header.thirdDimension?3:2;var outputLngLatArray=[];// The data either contains lat/lng or lat/lng/z values that will be decoded.
// precisionDivisors are the divisors needed to convert the values from integers
// back to floating-point.
var precisionDivisors=[Math.pow(10,header.precisionLngLat),Math.pow(10,header.precisionLngLat),Math.pow(10,header.precisionThirdDimension)];// maxAllowedValues are the maximum absolute values allowed for lat/lng/z. This is used for
// error-checking the coordinate values as they're being decoded.
var maxAllowedValues=[90,180,Infinity];// While decoding, we want to switch from lat/lng/z to lng/lat/z, so this index tells us
// what position to put the dimension in for the resulting coordinate.
var resultDimensionIndex=[1,0,2];// Decoded values are deltas from the previous coordinate values, so track the previous values.
var lastScaledCoordinate=[0,0,0];// Keep decoding until we reach the end of the string.
while(index<encoded.length){// Each time through the loop we'll decode one full coordinate.
var coordinate=[];var deltaValue=0;// Decode each dimension for the coordinate.
for(var dimension=0;dimension<numDimensions;dimension+=1){if(index>=encoded.length){throw Error("Encoding unexpectedly ended early.")}var _this$decodeSignedVal=this.decodeSignedValue(encoded,index);var _this$decodeSignedVal2=_slicedToArray(_this$decodeSignedVal,2);deltaValue=_this$decodeSignedVal2[0];index=_this$decodeSignedVal2[1];lastScaledCoordinate[dimension]+=deltaValue;// Get the final lat/lng/z value by scaling the integer back down based on the number of
// digits of precision.
var value=lastScaledCoordinate[dimension]/precisionDivisors[dimension];if(Math.abs(value)>maxAllowedValues[dimension]){throw Error("Invalid input. Compressed data contains invalid coordinate value: ".concat(value))}coordinate[resultDimensionIndex[dimension]]=value}outputLngLatArray.push(coordinate)}return[outputLngLatArray,header]}}])}();// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// This class implements the Encoded Polyline Algorithm Format
// (https://developers.google.com/maps/documentation/utilities/polylinealgorithm).
// This algorithm is commonly used with either 5 or 6 bits of precision.
// To improve usability and decrease user error, we present Polyline5 and Polyline6
// as two distinct compression algorithms.
var EncodedPolyline=/*#__PURE__*/function(_DataCompressor){function EncodedPolyline(precision){var _this2;_classCallCheck(this,EncodedPolyline);_this2=_callSuper(this,EncodedPolyline);// The original Encoded Polyline algorithm doesn't support having a header on the encoded data.
_this2.DataContainsHeader=false;_this2.PolylineEncodingTable="?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";// The lookup table contains conversion values for ASCII characters 0-127.
// Only the characters listed in the encoding table will contain valid
// decoding entries below.
_this2.PolylineDecodingTable=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,-1];_this2.encoder=new PolylineEncoder(_this2.PolylineEncodingTable,_this2.DataContainsHeader);_this2.decoder=new PolylineDecoder(_this2.PolylineDecodingTable,_this2.DataContainsHeader);_this2.precision=precision;return _this2}_inherits(EncodedPolyline,_DataCompressor);return _createClass(EncodedPolyline,[{key:"compressLngLatArray",value:function compressLngLatArray(lngLatArray){return this.encoder.encode(lngLatArray,this.precision)}},{key:"decompressLngLatArray",value:function decompressLngLatArray(compressedData){var _this$decoder$decode=this.decoder.decode(compressedData,this.precision),_this$decoder$decode2=_slicedToArray(_this$decoder$decode,2),lngLatArray=_this$decoder$decode2[0],header=_this$decoder$decode2[1];return[lngLatArray,{precisionLngLat:header.precisionLngLat}]}}])}(DataCompressor);// Polyline5 and Polyline6 encodes/decodes compressed data with 5 or 6 bits of precision respectively.
// While the underlying Polyline implementation allows for an arbitrary
// number of bits of precision to be encoded / decoded, location service providers seem
// to only choose 5 or 6 bits of precision, so those are the two algorithms that we'll explicitly offer here.
var Polyline5=/*#__PURE__*/function(_EncodedPolyline){function Polyline5(){_classCallCheck(this,Polyline5);return _callSuper(this,Polyline5,[5])}_inherits(Polyline5,_EncodedPolyline);return _createClass(Polyline5)}(EncodedPolyline);var Polyline6=/*#__PURE__*/function(_EncodedPolyline2){function Polyline6(){_classCallCheck(this,Polyline6);return _callSuper(this,Polyline6,[6])}_inherits(Polyline6,_EncodedPolyline2);return _createClass(Polyline6)}(EncodedPolyline);// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// This class implements the Flexible-Polyline variation of the
// Encoded Polyline algorithm (https://github.com/heremaps/flexible-polyline).
// The algorithm supports both 2D and 3D data.
var FlexiblePolyline=/*#__PURE__*/function(_DataCompressor2){function FlexiblePolyline(){var _this3;_classCallCheck(this,FlexiblePolyline);_this3=_callSuper(this,FlexiblePolyline);_this3.DataContainsHeader=true;_this3.FlexPolylineEncodingTable="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";// The lookup table contains conversion values for ASCII characters 0-127.
// Only the characters listed in the encoding table will contain valid
// decoding entries below.
_this3.FlexPolylineDecodingTable=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,63,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];_this3.encoder=new PolylineEncoder(_this3.FlexPolylineEncodingTable,_this3.DataContainsHeader);_this3.decoder=new PolylineDecoder(_this3.FlexPolylineDecodingTable,_this3.DataContainsHeader);return _this3}_inherits(FlexiblePolyline,_DataCompressor2);return _createClass(FlexiblePolyline,[{key:"compressLngLatArray",value:function compressLngLatArray(lngLatArray,parameters){// Set any parameters that weren't passed in to their default values.
var DefaultCompressionParameters={precisionLngLat:DefaultPrecision,precisionThirdDimension:DefaultPrecision,thirdDimension:ThirdDimension.None};var fullParameters=Object.assign(Object.assign({},DefaultCompressionParameters),parameters);return this.encoder.encode(lngLatArray,fullParameters.precisionLngLat,fullParameters.thirdDimension,fullParameters.precisionThirdDimension)}},{key:"decompressLngLatArray",value:function decompressLngLatArray(encodedData){var _this$decoder$decode3=this.decoder.decode(encodedData),_this$decoder$decode4=_slicedToArray(_this$decoder$decode3,2),lngLatArray=_this$decoder$decode4[0],header=_this$decoder$decode4[1];return[lngLatArray,header]}}])}(DataCompressor);// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// The default algorithm is FlexiblePolyline. This was selected as it is the newest and most flexible format
// of the different decoding types supported.
var compressor=new FlexiblePolyline;/** Get the currently-selected compression algorithm.
	 * @returns The current compression algorithm.
	 */function getCompressionAlgorithm(){if(compressor instanceof FlexiblePolyline){return CompressionAlgorithm.FlexiblePolyline}if(compressor instanceof Polyline5){return CompressionAlgorithm.Polyline5}if(compressor instanceof Polyline6){return CompressionAlgorithm.Polyline6}throw new Error("Invalid polyline compression algorithm.")}/** Set the compression algorithm to use for subsequent encode/decode calls.
	 * @param compressionType The compression algorithm to use.
	 * @throws Error() if an invalid compression algorithm is specified.
	 */function setCompressionAlgorithm(compressionType){switch(compressionType){case CompressionAlgorithm.FlexiblePolyline:{if(!(compressor instanceof FlexiblePolyline)){compressor=new FlexiblePolyline}break}case CompressionAlgorithm.Polyline5:{if(!(compressor instanceof Polyline5)){compressor=new Polyline5}break}case CompressionAlgorithm.Polyline6:{if(!(compressor instanceof Polyline6)){compressor=new Polyline6}break}default:{throw new Error("Invalid polyline compression algorithm.")}}}/** Encode the provided array of coordinate values into an encoded string.
	 * @remarks
	 * This takes in an array of two-dimensional or three-dimensional positions and encodes them into
	 * the currently-selected compression format.
	 * Example of 2D input data:
	 * ```typescript
	 *   [ [5.0, 0.0], [10.0, 5.0], [10.0, 10.0], ]
	 * ```
	 * Example of 3D input data:
	 * ```typescript
	 *   [ [5.0, 0.0, 200.0], [10.0, 5.0, 200.0], [10.0, 10.0, 205.0], ]
	 * ```
	 * @param lngLatArray  An array of lng/lat positions to encode. The positions may contain an optional 3rd dimension.
	 * @param parameters Optional compression parameters. These are currently only used by the FlexiblePolyline algorithm.
	 * @returns An encoded string containing the compressed coordinate values.
	 * @throws Error() if the input data contains no coordinate pairs,
	 * latitude values outside of [-90, 90], longitude values outside of [-180, 180],
	 * data that isn't 2-dimensional or 3-dimensional, or data that is 3-dimensional with a compressor that doesn't support 3D data.
	 */function encodeFromLngLatArray(lngLatArray){var parameters=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return compressor.encodeFromLngLatArray(lngLatArray,parameters)}/** Decode the provided encoded data string into an array of coordinate values.
	 * @remarks
	 * Note that this method returns a raw array of coordinate values, which cannot be used as a MapLibre source
	 * without first embedding it into a GeoJSON Feature. If you want to add the decoded data as a MapLibre source,
	 * use either {@link decodeToLineStringFeature} or {@link decodeToPolygonFeature} instead.
	 * Only use this method when you want to use the coordinate data directly.
	 * @param compressedData  The encoded data string to decode. The data is expected to have valid lat/lng values.
	 * @returns An array of coordinate value arrays.
	 * @throws Error() if the encodedData contains invalid characters, no coordinate pairs,
	 * latitude values outside of [-90, 90], or longitude values outside of [-180, 180].
	 * @example
	 * An example of decoded data:
	 * ```typescript
	 *   [
	 *     [5.0, 0.0],
	 *     [10.0, 5.0],
	 *     [10.0, 10.0],
	 *   ]
	 * ```
	 */function decodeToLngLatArray(compressedData){return compressor.decodeToLngLatArray(compressedData)}/** Decode the provided encoded data string into a GeoJSON LineString.
	 * @remarks
	 * Note that this method returns a LineString, which cannot be used as a MapLibre source without first embedding it
	 * into a GeoJSON Feature. If you want to add the LineString as a MapLibre source, use {@link decodeToLineStringFeature} instead.
	 * Only use this method when you plan to manipulate the LineString further as opposed to using it directly as a source.
	 * @param encodedData  The encoded data string to decode. The data is expected to have a minimum of two
	 * coordinate pairs with valid lat/lng values.
	 * @returns A GeoJSON LineString representing the decoded data.
	 * @throws Error() if the encodedData contains invalid characters, < 2 coordinate pairs,
	 * latitude values outside of [-90, 90], or longitude values outside of [-180, 180].
	 * @example
	 * An example of a decoded LineString:
	 * ```json
	 * {
	 *   "type": "LineString",
	 *   "coordinates": [
	 *     [5.0, 0.0],
	 *     [10.0, 5.0],
	 *     [10.0, 10.0],
	 *   ]
	 * }
	 * ```
	 */function decodeToLineString(encodedData){return compressor.decodeToLineString(encodedData)}/** Decode the provided encoded data string into a GeoJSON Polygon.
	 * @remarks
	 * Note that this method returns a Polygon, which cannot be used as a MapLibre source without first embedding it
	 * into a GeoJSON Feature. If you want to add the Polygon as a MapLibre source, use {@link decodeToPolygonFeature} instead.
	 * Only use this method when you plan to manipulate the Polygon further as opposed to using it directly as a source.
	 * @param encodedData  An array of encoded data strings to decode. This is an array instead of a single string
	 * because polygons can consist of multiple rings of compressed data. The first entry will be treated as the
	 * outer ring and the remaining entries will be treated as inner rings. Each input ring can be wound either
	 * clockwise or counterclockwise; they will get rewound to be GeoJSON-compliant in the output. Each ring is
	 * expected to have a minimum of four coordinate pairs with valid lat/lng data, and the last coordinate pair
	 * must match the first to make an explicit ring.
	 * @returns A GeoJSON Polygon representing the decoded data. The first entry in the output coordinates
	 * represents the outer ring and any remaining entries represent inner rings.
	 * @throws Error() if the encodedData contains invalid characters, < 4 coordinate pairs, first/last coordinates that
	 * aren't approximately equal, latitude values outside of [-90, 90], or longitude values outside of [-180, 180].
	 * @example
	 * An example of a decoded Polygon:
	 * ```json
	 * {
	 *   "type": "Polygon",
	 *   "coordinates": [
	 *     [[0, 0], [10, 0], [10, 10], [0, 10], [0, 0]], // outer ring
	 *     [[2, 2], [2,  8], [8 , 8 ], [8 , 2], [2, 2]], // inner ring
	 *     [[4, 4], [4,  6], [6 , 6 ], [6 , 4], [4, 4]]  // inner ring
	 *   ]
	 * }
	 * ```
	 */function decodeToPolygon(encodedData){return compressor.decodeToPolygon(encodedData)}/** Decode the provided encoded data string into a GeoJSON Feature containing a LineString.
	 * @param encodedData  The encoded data string to decode. The data is expected to have a minimum of two
	 * coordinate pairs with valid lat/lng values.
	 * @returns A GeoJSON Feature containing a LineString that represents the decoded data.
	 * @throws Error() if the encodedData contains invalid characters, < 2 coordinate pairs,
	 * latitude values outside of [-90, 90], or longitude values outside of [-180, 180]
	 * @example
	 * An example of a decoded LineString as a Feature:
	 * ```json
	 * {
	 *   "type": "Feature",
	 *   "properties": {},
	 *   "geometry": {
	 *     "type": "LineString",
	 *     "coordinates": [
	 *       [5.0, 0.0],
	 *       [10.0, 5.0],
	 *       [10.0, 10.0],
	 *     ]
	 *   }
	 * }
	 * ```
	 * The result of this method can be used with MapLibre's `addSource` to add a named data source or embedded directly
	 * with MapLibre's `addLayer` to both add and render the result:
	 * ```javascript
	 * var decodedGeoJSON = polylineDecoder.decodeToLineStringFeature(encodedRoutePolyline);
	 * map.addLayer({
	 *   id: 'route',
	 *   type: 'line',
	 *     source: {
	 *       type: 'geojson',
	 *       data: decodedGeoJSON
	 *     },
	 *     layout: {
	 *       'line-join': 'round',
	 *       'line-cap': 'round'
	 *     },
	 *       paint: {
	 *         'line-color': '#3887be',
	 *         'line-width': 5,
	 *         'line-opacity': 0.75
	 *       }
	 * });
	 * ```
	 */function decodeToLineStringFeature(encodedData){return compressor.decodeToLineStringFeature(encodedData)}/** Decode the provided encoded data string into a GeoJSON Feature containing a Polygon.
	 * @param encodedData  An array of encoded data strings to decode. This is an array instead of a single string
	 * because polygons can consist of multiple rings of compressed data. The first entry will be treated as the
	 * outer ring and the remaining entries will be treated as inner rings. Each input ring can be wound either
	 * clockwise or counterclockwise; they will get rewound to be GeoJSON-compliant in the output. Each ring is
	 * expected to have a minimum of four coordinate pairs with valid lat/lng data, and the last coordinate pair
	 * must match the first to make an explicit ring.
	 * @returns A GeoJSON Feature containing a Polygon that represents the decoded data. The first entry in the
	 * output coordinates represents the outer ring and any remaining entries represent inner rings.
	 * @throws Error() if the encodedData contains invalid characters, < 4 coordinate pairs, first/last coordinates that
	 * aren't approximately equal, latitude values outside of [-90, 90], or longitude values outside of [-180, 180].
	 * @example
	 * An example of a decoded Polygon as a Feature:
	 * ```json
	 * {
	 *   'type': 'Feature',
	 *   'properties': {},
	 *   'geometry': {
	 *     "type": "Polygon",
	 *     "coordinates": [
	 *       [[0, 0], [10, 0], [10, 10], [0, 10], [0, 0]], // outer ring
	 *       [[2, 2], [2,  8], [8 , 8 ], [8 , 2], [2, 2]], // inner ring
	 *       [[4, 4], [4,  6], [6 , 6 ], [6 , 4], [4, 4]]  // inner ring
	 *     ]
	 *   }
	 * }
	 * ```
	 * The result of this method can be used with MapLibre's `addSource` to add a named data source or embedded directly
	 * with MapLibre's `addLayer` to both add and render the result:
	 * ```javascript
	 * var decodedGeoJSON = polylineDecoder.decodeToPolygonFeature(encodedIsolinePolygons);
	 * map.addLayer({
	 *   id: 'isoline',
	 *   type: 'fill',
	 *     source: {
	 *       type: 'geojson',
	 *       data: decodedGeoJSON
	 *     },
	 *     layout: {},
	 *     paint: {
	 *       'fill-color': '#FF0000',
	 *       'fill-opacity': 0.6
	       }
	 * });
	 * ```
	 */function decodeToPolygonFeature(encodedData){return compressor.decodeToPolygonFeature(encodedData)}})})(polyline);// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __rest$1=undefined&&undefined.__rest||function(s,e){var t={};for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0)t[p]=s[p];if(s!=null&&typeof Object.getOwnPropertySymbols==="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++){if(e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i]))t[p[i]]=s[p[i]]}return t};const defaultBaseGeoRoutesOptions={flattenProperties:true};const defaultCalculateRoutesResponseOptions=Object.assign(Object.assign({},defaultBaseGeoRoutesOptions),{includeLegs:true,includeTravelStepGeometry:false,includeSpans:false,includeLegArrivalDeparturePositions:false,includeTravelStepStartPositions:false});/**
 * This converts a CalculateRoutesResponse to an array of GeoJSON FeatureCollections, one for each route in the
 * response. Route responses contain multiple different types of geometry in the response, so the conversion is
 * configurable to choose which features should be in the resulting GeoJSON. Each GeoJSON Feature contains properties
 * from that portion of the response along with any child arrays/structures. It will not contain properties from any
 * parent structures. So for example, with Route->Leg->TravelSteps, a converted Leg feature will contain properties for
 * everything on Leg and everything in TravelSteps, but it won't contain any properties from Route.
 *
 * Each Feature contains a `FeatureType` property that can be used to distinguish between the types of features if
 * multiple are requested during the conversion:
 *
 * - `Leg`: A travel leg of the route. (LineString)
 * - `Span`: A span within a travel leg. (LineString)
 * - `TravelStepGeometry`: A travel step line within a travel leg. (LineString)
 * - `TravelStepStartPosition`: The start position of a travel step within a travel leg. (Point)
 * - `Arrival`: The arrival position of a travel leg. (Point)
 * - `Departure`: The departure position of a travel leg. (Point)
 *
 * Each FeatureCollection may contain a mixture of LineString and Point features, depending on the conversion options
 * provided.
 *
 * Any feature that is missing its geometry in the response or has invalid geometry will throw an Error.
 *
 * @example Drawing a route with travel step dots and hover-over popups at each travel step.
 *
 * ```js
 *         const popup = new maplibregl.Popup({
 *             closeButton: false,
 *             closeOnClick: false
 *         });
 *
 *         // Set up command to calculate route between 2 points
 *         const calculateRouteCommand =
 *             new amazonLocationClient.routes.CalculateRoutesCommand(params);
 *
 *         try {
 *             const response = await client.send(calculateRouteCommand);
 *
 *             const collections = amazonLocationDataConverter.calculateRoutesResponseToFeatureCollections(response, {
 *                 flattenProperties: true,
 *                 includeTravelStepGeometry: true,
 *                 includeLegs: true,
 *                 includeSpans: true,
 *                 includeLegArrivalDeparturePositions: true,
 *                 includeTravelStepStartPositions: true,
 *                 });
 *
 *             if (response.Routes.length > 0) {
 *                 // This is only adding a source for the first route in the returned collection.
 *                 // If all the routes are desired, add sources for each entry in collections[].
 *                 map.addSource("route-0", { type: "geojson", data: collections[0]});
 *
 *                 // This layer filters the GeoJSON to only draw lines of type TravelStepGeometry.
 *                 map.addLayer({
 *                     id: `route-0`,
 *                     type: 'line',
 *                     source: "route-0",
 *                     filter: ['all',
 *                         ['==', ['get', 'FeatureType'], 'TravelStepGeometry'],
 *                     ],
 *                     layout: {
 *                         'line-join': 'round',
 *                         'line-cap': 'round'
 *                     },
 *                     paint: {
 *                         'line-color': '#3887be',
 *                         'line-width': 5,
 *                         'line-opacity': 0.75
 *                     }
 *                 });
 *
 *                 // This layer filters the GeoJSON to only draw points of type TravelStepStartPosition.
 *                 map.addLayer({
 *                     id: "route-0-travelsteps",
 *                     type: "circle",
 *                     source: "route-0",
 *                     filter: ['all',
 *                         ['==', ['get', 'FeatureType'], 'TravelStepStartPosition'],
 *                     ],
 *                     paint: {
 *                         "circle-radius": 6,
 *                         "circle-color": "#B42222",
 *                     },
 *                 });
 *
 *                 // Show a popup on mouseenter with the directions, distance, and duration.
 *                 map.on('mouseenter', 'route-0-travelsteps', (e) => {
 *                     map.getCanvas().style.cursor = 'pointer';
 *
 *                     if (e.features.length > 0) {
 *                         const feature = e.features[0];
 *                         const coordinates = feature.geometry.coordinates.slice();
 *                         let title = e.features[0].properties['Type'] || '';
 *                         if (e.features[0].properties['TurnStepDetails.SteeringDirection']) {
 *                             title = title + ' ' + e.features[0].properties['TurnStepDetails.SteeringDirection'];
 *                         }
 *                         if (e.features[0].properties['RampStepDetails.SteeringDirection']) {
 *                             title = title + ' ' + e.features[0].properties['RampStepDetails.SteeringDirection'];
 *                         }
 *                         if (e.features[0].properties['KeepStepDetails.SteeringDirection']) {
 *                             title = title + ' ' + e.features[0].properties['KeepStepDetails.SteeringDirection'];
 *                         }
 *                         const distance = e.features[0].properties['Distance'] || '';
 *                         const duration = e.features[0].properties['Duration'] || '';
 *
 *                         // Create popup content
 *                         const popupContent = `
 *         <h3>${title}</h3>
 *         <p><strong>Distance:</strong> ${distance}</p>
 *         <p><strong>Duration:</strong> ${duration}</p>
 *       `;
 *
 *                         // Set popup coordinates and content
 *                         popup
 *                           .setLngLat(e.lngLat)
 *                           .setHTML(popupContent)
 *                           .addTo(map);
 *                     }
 *                 });
 *
 *                 // Remove popup on mouseleave
 *                 map.on('mouseleave', 'route-0-travelsteps', () => {
 *                     map.getCanvas().style.cursor = '';
 *                     popup.remove();
 *                 });
 * ```
 */function calculateRoutesResponseToFeatureCollections(routesResponse,options){const routes=[];// Any options that weren't passed in will get set to default values.
options=Object.assign(Object.assign({},defaultCalculateRoutesResponseOptions),options);// CalculateRoutes can return multiple alternate routes, so loop through and create
// a FeatureCollection for each route.
for(const route of routesResponse.Routes){const routeCollection={type:"FeatureCollection",features:[]};// When converting a Route into GeoJSON, we can add properties at the Feature level, but not at the
// FeatureCollection level. Consequently, our choice of what to convert into a Feature has implications
// on what metadata is preserved and what metadata is ignored. The approach we've taken below is to include
// metadata from all children, but not from the parents. This is because parent metadata would get duplicated
// for each child and isn't necessarily relevant at that level.
// For example, the response structure has Route->Legs->TravelSteps.
// If we convert each Leg as a feature, each Leg feature will have properties for all the Leg metadata and all
// the TravelSteps metadata. It will not contain any Route metadata.
// If we convert each TravelStep as a feature, those will only have properties for that TravelStep, and none of
// the Leg or Route metadata.
for(const leg of route.Legs){if(leg.Geometry){// Convert the compressed or uncompressed geometry into an uncompressed GeoJSON LineString.
const legLineString=createLineString(leg.Geometry);// If we don't have a valid leg LineString, we can't convert anything from this leg into GeoJSON.
// Skip it and move on to the next leg.
if(legLineString.coordinates.length<2){throw Error("Route leg has invalid geometry.")}// Generically reference the appropriate LegDetails structure for this leg.
const legDetails=leg.VehicleLegDetails?leg.VehicleLegDetails:leg.PedestrianLegDetails?leg.PedestrianLegDetails:leg.FerryLegDetails?leg.FerryLegDetails:null;// If includeLegs is requested, we'll include a LineString feature for each Leg in the Route,
// with all the Leg properties except for the Geometry property, since that would be
// redundant with the Feature geometry.
// These features have FeatureType = "Leg".
if(options.includeLegs){// eslint-disable-next-line @typescript-eslint/no-unused-vars
const legProperties=__rest$1(leg,["Geometry"]);legProperties["FeatureType"]="Leg";addFeatureToCollection(routeCollection,options.flattenProperties,legProperties,legLineString)}// If includeLegArrivalDeparturePositions is requested, we'll include Point features for the arrival
// and departure positions for each leg.
// These features have FeatureType = "Arrival" or "Departure".
if(options.includeLegArrivalDeparturePositions){if(legDetails){for(const point of[legDetails.Departure,legDetails.Arrival]){const pointProperties=structuredClone(point);delete pointProperties.Place.Position;pointProperties["FeatureType"]=point===legDetails.Departure?"Departure":"Arrival";addFeatureToCollection(routeCollection,options.flattenProperties,pointProperties,{type:"Point",coordinates:point.Place.Position})}}}// If includeTravelStepGeometry is requested, we'll include a LineString feature for each TravelStep
// in each Leg in the Route, with all the TravelStep properties except for the GeometryOffset property.
// GeometryOffset is only needed for calculating the LineString belonging to the TravelStep, so there's
// no reason to leave it in the results. TravelStep lines are useful for associating with information about
// the route between each travel step, such as distance and time.
// These features have FeatureType = "TravelStepGeometry".
if(options.includeTravelStepGeometry){extractNestedLinesIntoCollection(routeCollection,"TravelStepGeometry",legLineString,legDetails===null||legDetails===void 0?void 0:legDetails.TravelSteps,options.flattenProperties)}// If includeTravelStepStartPositions is requested, we'll include a Point feature for each TravelStep.
// TravelStep start positions are useful for associating with the turn-by-turn direction information at
// the exact location that it is needed.
// These features have FeatureType = "TravelStepStartPosition".
if(options.includeTravelStepStartPositions){extractNestedPointsIntoCollection(routeCollection,"TravelStepStartPosition",legLineString,legDetails===null||legDetails===void 0?void 0:legDetails.TravelSteps,options.flattenProperties)}// If includeSpans is requested, we'll include a LineString feature for each Span in each Leg in
// the Route, with all the Span properties except for the GeometryOffset property.
// These features have FeatureType = "Span".
if(options.includeSpans){extractNestedLinesIntoCollection(routeCollection,"Span",legLineString,legDetails===null||legDetails===void 0?void 0:legDetails.Spans,options.flattenProperties)}}}routes.push(routeCollection)}return routes}const defaultCalculateIsolinesResponseOptions=defaultBaseGeoRoutesOptions;/**
 * This converts a CalculateIsolineResponse to a GeoJSON FeatureCollection which contains one Feature for each isoline
 * in the response. Isolines can contain both polygons for isoline regions and lines for connectors between regions
 * (such as ferry travel), so each Feature contains either a GeometryCollection with a mix of Polygons and LineStrings
 * or a single Polygon.
 *
 * Any feature that is missing its geometry in the response or has invalid geometry will throw an Error.
 *
 * @example Drawing an isolines response with multiple isoline regions and connector lines.
 *
 * ```js
 *         // Set up command to calculate isolines
 *         const calculateIsolinesCommand =
 *             new amazonLocationClient.routes.CalculateIsolinesCommand(params);
 *
 *         try {
 *             const response = await client.send(calculateIsolinesCommand);
 *
 *             const collection = amazonLocationDataConverter.calculateIsolinesResponseToFeatureCollection(response, {
 *                 flattenProperties: true
 *                 });
 *
 *             // Add the results as a GeoJSON source
 *             map.addSource('isolines', { type: 'geojson', data: collection});
 *
 *             // Add a layer for drawing the isoline polygon regions.
 *             // It's important to filter the geometry type to polygons, because any connector lines
 *             // in the results would still try to draw a filled region on one side of the line.
 *             // These are being drawn as partially translucent so that overlapping isoline regions
 *             // additively get more opaque.
 *             map.addLayer({
 *                 id: 'isolines',
 *                 type: 'fill',
 *                 source: 'isolines',
 *                 layout: {
 *                 },
 *                 paint: {
 *                     "fill-color": "#3887be",
 *                     'fill-opacity': 0.6
 *                 },
 *                 'filter': ['==', ['geometry-type'], 'Polygon']
 *             });
 *
 *             // Draw any connector lines that exist in the result.
 *             // It's important to filter the geometry type to LineStrings. Otherwise, any polygons
 *             // would have their outlines drawn here as well.
 *             map.addLayer({
 *                 id: 'isolines-connector',
 *                 type: 'line',
 *                 source: 'isolines',
 *                 layout: {
 *                     'line-join': 'round',
 *                     'line-cap': 'round'
 *                 },
 *                 paint: {
 *                     'line-color': '#FF0000',  // Default color
 *                     'line-width': 3,
 *                     'line-opacity': 0.75
 *                 },
 *                 'filter': ['==', ['geometry-type'], 'LineString']
 *             });
 * ```
 */function calculateIsolinesResponseToFeatureCollection(isolinesResponse,options){// Set any options that weren't passed in to the default values.
options=Object.assign(Object.assign({},defaultCalculateIsolinesResponseOptions),options);const isolines={type:"FeatureCollection",features:[]};// CalculateIsolines can return multiple distinct isolines, so loop through and create
// a Feature containing a GeometryCollection for each isoline.
for(const isoline of isolinesResponse.Isolines){// eslint-disable-next-line @typescript-eslint/no-unused-vars
const properties=__rest$1(isoline,["Geometries","Connections"]);const feature={type:"Feature",id:isolines.features.length,properties:options.flattenProperties?flattenProperties(properties,""):properties,geometry:{type:"GeometryCollection",geometries:[]}};// Add all the isoline polygons into the GeometryCollection.
for(const geometry of isoline.Geometries){const polygon=createPolygon(geometry);if(polygon.coordinates.length>0){feature.geometry.geometries.push(polygon)}}// Add all the isoline connection lines into the GeometryCollection.
for(const connection of isoline.Connections){const connectionLine=createLineString(connection.Geometry);if(connectionLine.coordinates.length>1){feature.geometry.geometries.push(connectionLine)}}// As long as this feature has at least one polygon or line, add it to the result set.
if(feature.geometry.geometries.length>0){if(feature.geometry.geometries.length===1&&feature.geometry.geometries[0].type==="Polygon"){// GeometryCollections containing single geometries trigger GeoJSONLint warnings:
//     GeometryCollection with a single geometry should be avoided in favor of single part
//     or a single object of multi-part type
// in practice, the geometry type for single-geometry isolines is Polygon; LineStrings are
// supplemental and appear when multiple polygons are present, representing the connection
// between those areas
isolines.features.push(Object.assign(Object.assign({},feature),{geometry:feature.geometry.geometries[0]}))}else{isolines.features.push(feature)}}}return isolines}const defaultOptimizeWaypointsResponseOptions=defaultBaseGeoRoutesOptions;/**
 * This converts an OptimizeWaypointsResponse to a GeoJSON FeatureCollection which contains one Feature for each
 * waypoint in the response. The response can contain either impeding waypoints or optimized waypoints. They will both
 * get added into the GeoJSON with a FeatureType property of ImpedingWaypoint or OptimizedWaypoint respectively.
 *
 * @example Drawing labels underneath the waypoints that show the optimized order.
 *
 * ```js
 *         // Set up command to optimize waypoints
 *         const optimizeWaypointsCommand =
 *             new amazonLocationClient.routes.OptimizeWaypointsCommand(params);
 *
 *         try {
 *             const response = await client.send(optimizeWaypointsCommand);
 *
 *             const collection = amazonLocationDataConverter.optimizeWaypointsResponseToFeatureCollection(response, {
 *                 flattenProperties: true
 *                 });
 *
 *             // Add the GeoJSON collection as a source to the map
 *             map.addSource('waypoints', { type: 'geojson', data: collection});
 *
 *             // Add a layer that draws the numeric id of each point underneath the location.
 *             map.addLayer({
 *                 id: 'waypoint-numbers',
 *                 type: 'symbol',
 *                 source: 'waypoints',
 *                 layout: {
 *                     'text-field': ['id'],
 *                     "text-font": ["Amazon Ember Regular"],
 *                     'text-size': 18,
 *                     'text-offset': [0, 1.5],
 *                     'text-anchor': 'bottom'
 *                 },
 *                 paint: {
 *                     'text-color': '#000000',
 *                     'text-halo-color': '#FFFFFF',
 *                     'text-halo-width': 1
 *                 },
 *             });
 * ```
 */function optimizeWaypointsResponseToFeatureCollection(waypointsResponse,options){const waypoints={type:"FeatureCollection",features:[]};// Set any options that weren't passed in to the default values.
options=Object.assign(Object.assign({},defaultOptimizeWaypointsResponseOptions),options);// If there are impeding waypoints that cause the optimize call to fail, add them to the GeoJSON result
// with a FeatureType of ImpedingWaypoint.
for(const impedingWaypoint of waypointsResponse.ImpedingWaypoints){// eslint-disable-next-line @typescript-eslint/no-unused-vars
const properties=__rest$1(impedingWaypoint,["Position"]);properties["FeatureType"]="ImpedingWaypoint";addFeatureToCollection(waypoints,options.flattenProperties,properties,{type:"Point",coordinates:impedingWaypoint.Position})}// If the waypoints were optimized successfully, add them to the GeoJSON result with a
// FeatureType of OptimizedWaypoint.
for(const optimizedWaypoint of waypointsResponse.OptimizedWaypoints){// eslint-disable-next-line @typescript-eslint/no-unused-vars
const properties=__rest$1(optimizedWaypoint,["Position"]);properties["FeatureType"]="OptimizedWaypoint";addFeatureToCollection(waypoints,options.flattenProperties,properties,{type:"Point",coordinates:optimizedWaypoint.Position})}return waypoints}const defaultSnapToRoadsResponseOptions=Object.assign(Object.assign({},defaultBaseGeoRoutesOptions),{includeSnappedGeometry:true,includeSnappedTracePointOriginalPositions:false,includeSnappedTracePointSnappedPositions:false,includeOriginalToSnappedPositionLines:false});/**
 * This converts a SnapToRoadsResponse to a GeoJSON FeatureCollection. The FeatureCollection may optionally contain any
 * combination of the following:
 *
 * - A LineString Feature with the snapped route geometry, if includeSnappedGeometry is true.
 * - Point Features for each original trace point, if includeSnappedTracePointOriginalPositions is true.
 * - Point Features for each snapped trace point, if includeSnappedTracePointSnappedPositions is true.
 * - LineString Features for each snap line (line from original to snapped trace point), if
 *   includeOriginalToSnappedPositionLines is true.
 *
 * Each Feature contains a `FeatureType` property that can be used to distinguish between the types of features if
 * multiple are requested during the conversion:
 *
 * - `SnappedGeometry`: The snapped route geometry.
 * - `SnappedTracePointOriginalPosition`: The original submitted trace point.
 * - `SnappedTracePointSnappedPosition`: The snapped trace point.
 * - `OriginalToSnappedPositionLine`: A line from the original trace point to the corresponding snapped trace point.
 *
 * @example Drawing the snapped route, dots for each snapped trace point, and lines from the original trace points to
 * the snapped trace points.
 *
 * ```js
 *         // Set up command to optimize waypoints
 *         const snapToRoadsCommand =
 *             new amazonLocationClient.routes.SnapToRoadsCommand(params);
 *
 *         try {
 *             const response = await client.send(snapToRoadsCommand);
 *
 *             const collection = amazonLocationDataConverter.snapToRoadsResponseToFeatureCollection(response, {
 *                 flattenProperties: true,
 *                 includeSnappedGeometry: true,
 *                 includeSnappedTracePointOriginalPositions: true,
 *                 includeSnappedTracePointSnappedPositions: true,
 *                 includeOriginalToSnappedPositionLines: true
 *                 });
 *
 *             // Add the GeoJSON results as a source to the map.
 *             map.addSource('snapped', { type: 'geojson', data: collection});
 *
 *             // Add a layer that only draws the snapped route calculated from the trace points.
 *             // This is done by filtering the FeatureType to SnappedGeometry.
 *             map.addLayer({
 *                 id: 'SnappedGeometry',
 *                 type: 'line',
 *                 source: 'snapped',
 *                 layout: {
 *                     'line-join': 'round',
 *                     'line-cap': 'round'
 *                 },
 *                 paint: {
 *                     'line-color': '#3887be',  // Default color
 *                     'line-width': 3,
 *                     'line-opacity': 0.75
 *                 },
 *                 filter: ['==', ['get', 'FeatureType'], 'SnappedGeometry']
 *             });
 *
 *             // Add a layer that only draws the lines from the submitted points to the snapped points.
 *             // We draw these separately so that we can draw these in a different color than the route.
 *             // Alternatively, we could've used a case statement on the line-color to switch it.
 *             map.addLayer({
 *                 id: 'snappedLines',
 *                 type: 'line',
 *                 source: 'snapped',
 *                 layout: {
 *                     'line-join': 'round',
 *                     'line-cap': 'round'
 *                 },
 *                 paint: {
 *                     'line-color': '#FF0000',  // Default color
 *                     'line-width': 3,
 *                     'line-opacity': 0.75
 *                 },
 *                 filter: ['==', ['get', 'FeatureType'], 'OriginalToSnappedPositionLine']
 *             });
 *
 *             // Add a layer that only draws circles at the snapped trace points.
 *             map.addLayer({
 *                 id: 'snappedTracePoints',
 *                 type: 'circle',
 *                 source: 'snapped',
 *                 filter: ['all',
 *                     ['==', ['get', 'FeatureType'], 'SnappedTracePointSnappedPosition']
 *                 ],
 *                 paint: {
 *                     'circle-radius': 5,
 *                     'circle-color': '#FF0000'
 *                 }
 *             });
 * ```
 */function snapToRoadsResponseToFeatureCollection(snapToRoadsResponse,options){// Set any options that weren't passed in to the default values.
options=Object.assign(Object.assign({},defaultSnapToRoadsResponseOptions),options);const snappedFeatures={type:"FeatureCollection",features:[]};// Optionally include a LineString for the route that all the TracePoints seem to trace out.
if(options.includeSnappedGeometry){// Create a shallow copy of the passed-in properties and remove "$metadata", which can appear
// in Response objects from the AWS SDK. Since $metadata is only metadata about the API call and
// not a part of the Response data, we don't want or need it to appear in the generated GeoJSON.
// We also remove SnappedGeometry, SnappedGeometryFormat, and SnappedTracePoints since these are
// all redundant with the geometry we're returning in the GeoJSON.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const properties=__rest$1(snapToRoadsResponse,["SnappedGeometry","SnappedGeometryFormat","SnappedTracePoints"]);properties["FeatureType"]="SnappedGeometry";delete properties["$metadata"];addFeatureToCollection(snappedFeatures,options.flattenProperties,properties,createLineString(snapToRoadsResponse.SnappedGeometry))}for(const snappedTracePoint of snapToRoadsResponse.SnappedTracePoints){// eslint-disable-next-line @typescript-eslint/no-unused-vars
const tracePointProperties=__rest$1(snappedTracePoint,["OriginalPosition","SnappedPosition"]);// Optionally include a Point for each original TracePoint submitted.
if(options.includeSnappedTracePointOriginalPositions){const originalProperties=Object.assign({},tracePointProperties);originalProperties["FeatureType"]="SnappedTracePointOriginalPosition";addFeatureToCollection(snappedFeatures,options.flattenProperties,originalProperties,{type:"Point",coordinates:snappedTracePoint.OriginalPosition})}// Optionally include a Point for each snapped TracePoint submitted.
if(options.includeSnappedTracePointSnappedPositions){const snappedProperties=Object.assign({},tracePointProperties);snappedProperties["FeatureType"]="SnappedTracePointSnappedPosition";addFeatureToCollection(snappedFeatures,options.flattenProperties,snappedProperties,{type:"Point",coordinates:snappedTracePoint.SnappedPosition})}// Optionally include a LineString for the line between the original and snapped TracePoint.
if(options.includeOriginalToSnappedPositionLines){const snapLineProperties=Object.assign({},tracePointProperties);snapLineProperties["FeatureType"]="OriginalToSnappedPositionLine";addFeatureToCollection(snappedFeatures,options.flattenProperties,snapLineProperties,{type:"LineString",coordinates:[snappedTracePoint.OriginalPosition,snappedTracePoint.SnappedPosition]})}}return snappedFeatures}/**
 * Helper function to add a Feature to a FeatureCollection.
 *
 * @param collection The FeatureCollection to add the Feature to.
 * @param flatten Whether to flatten the properties or not.
 * @param properties The original nested properties of the Feature.
 * @param geometry The geometry of the Feature.
 */function addFeatureToCollection(collection,flatten,properties,geometry){collection.features.push({type:"Feature",id:collection.features.length,properties:flatten?flattenProperties(properties,""):properties,geometry:geometry})}/**
 * Helper function to create a GeoJSON LineString from a compressed or uncompressed Geometry.
 *
 * @param geometry The LineString/Polyline geometry to convert.
 * @returns A GeoJSON LineString.
 */function createLineString(geometry){if(geometry.LineString){return{type:"LineString",coordinates:geometry.LineString}}else if(geometry.Polyline){return polyline.decodeToLineString(geometry.Polyline)}else{throw Error("Response is missing both the LineString and Polyline fields for the geometry.")}}/**
 * Helper function to create a GeoJSON Polygon from a compressed or uncompressed Geometry.
 *
 * @param geometry The IsolineShapeGeometry to convert.
 * @returns A GeoJSON Polygon.
 */function createPolygon(geometry){if(geometry.Polygon){return{type:"Polygon",coordinates:geometry.Polygon}}else if(geometry.PolylinePolygon){return polyline.decodeToPolygon(geometry.PolylinePolygon)}else{throw Error("Response is missing both the Polygon and PolylinePolygon fields for the geometry.")}}/**
 * Helper function to extract nested features into a FeatureCollection.
 *
 * @param features The FeatureCollection to add the features to.
 * @param lineFeatureType The value to add as a FeatureType property for extracted lines.
 * @param lineString The LineString to extract geometry from for the nested features.
 * @param featureList The list of features to extract.
 * @param flattenProperties Whether to flatten the properties or not.
 */function extractNestedLinesIntoCollection(features,lineFeatureType,lineString,featureList,flattenProperties){if(!featureList)return;for(const[index,feature]of featureList.entries()){// The featureList array contains an array of entries that each contain a GeometryOffset. The
// GeometryOffset of the entry is the starting coordinate value of that entry, and it ends at
// the GeometryOffset of the next entry, or at the end of the LineString if there are no more entries.
const stepLineString=Object.assign({},lineString);stepLineString.coordinates=lineString.coordinates.slice(feature["GeometryOffset"],index<featureList.length-1?featureList[index+1]["GeometryOffset"]+1:lineString.coordinates.length);// If this entry has a valid LineString add it to the FeatureCollection.
if(stepLineString.coordinates.length>1){// Create a copy of the properties with GeometryOffset removed, and FeatureType added.
const featureProperties=Object.assign({},feature);delete featureProperties["GeometryOffset"];featureProperties["FeatureType"]=lineFeatureType;addFeatureToCollection(features,flattenProperties,featureProperties,stepLineString)}}}/**
 * Helper function to extract nested features into a FeatureCollection.
 *
 * @param features The FeatureCollection to add the features to.
 * @param startPointFeatureType The value to add as a FeatureType property for extracted start points.
 * @param lineString The LineString to extract geometry from for the nested features.
 * @param featureList The list of features to extract.
 * @param flattenProperties Whether to flatten the properties or not.
 */function extractNestedPointsIntoCollection(features,startPointFeatureType,lineString,featureList,flattenProperties){if(!featureList)return;for(const[index,feature]of featureList.entries()){// The featureList array contains an array of entries that each contain a GeometryOffset. The
// GeometryOffset of the entry is the starting coordinate value of that entry, and it ends at
// the GeometryOffset of the next entry, or at the end of the LineString if there are no more entries.
const stepLineString=Object.assign({},lineString);stepLineString.coordinates=lineString.coordinates.slice(feature["GeometryOffset"],index<featureList.length-1?featureList[index+1]["GeometryOffset"]+1:lineString.coordinates.length);// If this entry has a valid Position add it to the FeatureCollection.
if(stepLineString.coordinates.length>0){// Create a copy of the properties with GeometryOffset removed, and FeatureType added.
const featureProperties=Object.assign({},feature);delete featureProperties["GeometryOffset"];featureProperties["FeatureType"]=startPointFeatureType;addFeatureToCollection(features,flattenProperties,featureProperties,{type:"Point",coordinates:stepLineString.coordinates[0]})}}}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __rest=undefined&&undefined.__rest||function(s,e){var t={};for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0)t[p]=s[p];if(s!=null&&typeof Object.getOwnPropertySymbols==="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++){if(e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i]))t[p[i]]=s[p[i]]}return t};/**
 * It converts tracker responses to a FeatureCollection with Point Features. It converts
 *
 * 1. GetDevicePositionResponse to a FeatureCollection with a single feature.
 * 2. BatchGetDevicePositionResponse, GetDevicePositionHistoryResponse, ListDevicePositionsResponse to a FeatureCollection
 *    with features corresponding to the entries in the response.
 *
 * Fields other than `Position` of the device position will be mapped into the properties of the corresponding Feature.
 *
 * @example Converting a GetDevicePosition result
 *
 * Result of GetDevicePosition:
 *
 * ```json
 * {
 *   "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "SampleTime": "2023-04-18T21:35:44Z",
 *   "Position": [-125.14, 49.29],
 *   "Accuracy": {
 *     "Horizontal": 1
 *   },
 *   "PositionProperties": {
 *     "RouteNumber": "66",
 *     "Speed": "45mph"
 *   }
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *         "SampleTime": "2023-04-18T21:33:44Z",
 *         "PositionProperties": {
 *           "RouteNumber": "66",
 *           "Speed": "45mph"
 *         },
 *         "Accuracy": {
 *           "Horizontal": 1
 *         }
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-125.14, 49.29]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a ListDevicePositions result
 *
 * Result of ListDevicePositions:
 *
 * ```json
 * {
 *   "Entries": [
 *     {
 *       "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "SampleTime": "2023-04-18T21:35:44Z",
 *       "Position": [-125.14, 49.29],
 *       "PositionProperties": {
 *         "RouteNumber": "66",
 *         "Speed": "45mph"
 *       },
 *       "Accuracy": {
 *         "Horizontal": 1
 *       }
 *     },
 *     {
 *       "DeviceId": "D775D81A-BF1B-4311-9D54-2DCCA2B0BECA",
 *       "SampleTime": "2023-04-18T21:40:44Z",
 *       "Position": [-120.57, 50.36]
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *         "SampleTime": "2023-04-18T21:35:44Z",
 *         "PositionProperties": {
 *           "RouteNumber": "66",
 *           "Speed": "45mph"
 *         },
 *         "Accuracy": {
 *           "Horizontal": 1
 *         }
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-125.14, 49.29]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "D775D81A-BF1B-4311-9D54-2DCCA2B0BECA",
 *         "SampleTime": "2023-04-18T21:40:44Z"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-120.57, 50.36]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a GetDevicePositionHistory result
 *
 * Result of GetDevicePositionHistory:
 *
 * ```json
 * {
 *   "DevicePositions": [
 *     {
 *       "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "SampleTime": "2023-04-18T21:35:44Z",
 *       "ReceivedTime": "2023-04-18T21:35:44Z",
 *       "Position": [-125.25, 49.32]
 *     },
 *     {
 *       "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "SampleTime": "2023-04-18T21:50:44Z",
 *       "ReceivedTime": "2023-04-18T21:50:44Z",
 *       "Position": [-125.14, 49.29]
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *         "SampleTime": "2023-04-18T21:35:44Z"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-125.25, 49.32]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *         "SampleTime": "2023-04-18T21:50:44Z"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-125.14, 49.29]
 *       }
 *     }
 *   ]
 * }
 * ```
 */function devicePositionsToFeatureCollection(devicePositions){if("Position"in devicePositions){const features=[convertDevicePositionToFeature(devicePositions)];return toFeatureCollection(features)}else if("DevicePositions"in devicePositions){const features=devicePositions.DevicePositions.map(result=>result&&convertDevicePositionToFeature(result));return toFeatureCollection(features)}else if("Entries"in devicePositions){const features=devicePositions.Entries.map(result=>result&&convertDevicePositionToFeature(result));return toFeatureCollection(features)}else{return emptyFeatureCollection()}}function convertDevicePositionToFeature(devicePosition){const{Position}=devicePosition,devicePositionProperties=__rest(devicePosition,["Position"]);if(Position){return{type:"Feature",properties:Object.assign({},devicePositionProperties),geometry:{type:"Point",coordinates:Position}}}}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * It converts a route to a GeoJSON FeatureCollection with a single MultiStringLine Feature, each LineString entry of
 * such MultiLineString represents a leg of the route.
 *
 * Fields other than `Legs` of the route will be mapped to a field of the Feature's properties.
 *
 * Any leg without the `Geometry` field will be skipped.
 *
 * Note: <b>IncludeLegGeometry</b> should be set to true when calling CalculateRoute or Geometry will not be present in
 * the result and such result will be converted to an empty MultiLineString.
 *
 * @example Converting a CalculateRoute result with 2 legs
 *
 * Result of CalculateRoute:
 *
 * ```json
 * {
 *   "Legs": [
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 10.88,
 *       "EndPosition": [123.0, 12.0],
 *       "Geometry": {
 *         "LineString": [
 *           [123.0, 11.0],
 *           [123.5, 11.5],
 *           [123.0, 12.0]
 *         ]
 *       },
 *       "StartPosition": [123.0, 11.0],
 *       "Steps": []
 *     },
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 9.4,
 *       "EndPosition": [123.0, 14.0],
 *       "Geometry": {
 *         "LineString": [
 *           [123.0, 12.0],
 *           [123.5, 13.5],
 *           [123.0, 14.0]
 *         ]
 *       },
 *       "StartPosition": [123.0, 12.0],
 *       "Steps": []
 *     }
 *   ],
 *   "Summary": {
 *     "DataSource": "Esri",
 *     "Distance": 1,
 *     "DistanceUnit": "Kilometers",
 *     "DurationSeconds": 30,
 *     "RouteBBox": [-123.149, 49.289, -123.141, 49.287]
 *   }
 * }
 * ```
 *
 * Output flattenProperties is false:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "Summary": {
 *           "DataSource": "Esri",
 *           "Distance": 1,
 *           "DistanceUnit": "Kilometers",
 *           "DurationSeconds": 30
 *         }
 *       },
 *       "geometry": {
 *         "type": "MultiLineString",
 *         "coordinates": [
 *           [
 *             [123.0, 11.0],
 *             [123.5, 11.5],
 *             [123.0, 12.0]
 *           ],
 *           [
 *             [123.0, 12.0],
 *             [123.5, 13.5],
 *             [123.0, 14.0]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * - Output flattenProperties is true:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DataSource": "Esri",
 *         "Distance": 1,
 *         "DistanceUnit": "Kilometers",
 *         "DurationSeconds": 30
 *       },
 *       "geometry": {
 *         "type": "MultiLineString",
 *         "coordinates": [
 *           [
 *             [123.0, 11.0],
 *             [123.5, 11.5],
 *             [123.0, 12.0]
 *           ],
 *           [
 *             [123.0, 12.0],
 *             [123.5, 13.5],
 *             [123.0, 14.0]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a CalculateRoute result with the second leg missing the `Geometry` field
 *
 * Result of CalculateRoute:
 *
 * ```json
 * {
 *   "Legs": [
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 10.88,
 *       "EndPosition": [123.0, 12.0],
 *       "Geometry": {
 *         "LineString": [
 *           [123.0, 11.0],
 *           [123.5, 11.5],
 *           [123.0, 12.0]
 *         ]
 *       },
 *       "StartPosition": [123.0, 11.0],
 *       "Steps": []
 *     },
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 10.7,
 *       "EndPosition": [123.0, 13.0],
 *       "StartPosition": [123.0, 12.0],
 *       "Steps": []
 *     },
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 9.4,
 *       "EndPosition": [123.0, 14.0],
 *       "Geometry": {
 *         "LineString": [
 *           [123.0, 13.0],
 *           [123.5, 13.5],
 *           [123.0, 14.0]
 *         ]
 *       },
 *       "StartPosition": [123.0, 13.0],
 *       "Steps": []
 *     }
 *   ],
 *   "Summary": {
 *     "DataSource": "Esri",
 *     "Distance": 1,
 *     "DistanceUnit": "Kilometers",
 *     "DurationSeconds": 30,
 *     "RouteBBox": [-123.149, 49.289, -123.141, 49.287]
 *   }
 * }
 * ```
 *
 * Output flattenProperties is false:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "Summary": {
 *           "DataSource": "Esri",
 *           "Distance": 1,
 *           "DistanceUnit": "Kilometers",
 *           "DurationSeconds": 30
 *         }
 *       },
 *       "geometry": {
 *         "type": "MultiLineString",
 *         "coordinates": [
 *           [
 *             [123.0, 11.0],
 *             [123.5, 11.5],
 *             [123.0, 12.0]
 *           ],
 *           [
 *             [123.0, 13.0],
 *             [123.5, 13.5],
 *             [123.0, 14.0]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * - Output flattenProperties is true:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DataSource": "Esri",
 *         "Distance": 1,
 *         "DistanceUnit": "Kilometers",
 *         "DurationSeconds": 30
 *       },
 *       "geometry": {
 *         "type": "MultiLineString",
 *         "coordinates": [
 *           [
 *             [123.0, 11.0],
 *             [123.5, 11.5],
 *             [123.0, 12.0]
 *           ],
 *           [
 *             [123.0, 13.0],
 *             [123.5, 13.5],
 *             [123.0, 14.0]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 */function routeToFeatureCollection(route,options){const{Legs}=route;return Legs?toFeatureCollection([convertRouteToFeature(route,options)]):emptyFeatureCollection()}/**
 * Convert an Amazon Location Service route object to a GeoJSON Feature.
 *
 * @param route The route object from Amazon Location Service.
 * @returns A GeoJSON Feature of the route object.
 */function convertRouteToFeature(route,options){var _a;const processedLegs=route.Legs.map(leg=>{var _a;return(_a=leg.Geometry)===null||_a===void 0?void 0:_a.LineString}).filter(leg=>leg);let properties={};if(options===null||options===void 0?void 0:options.flattenProperties){properties=flattenProperties(route.Summary,"")}else if(route.Summary){properties.Summary=Object.assign(Object.assign({},route.Summary),{RouteBBox:undefined})}delete properties.RouteBBox;return{type:"Feature",properties:properties,bbox:(_a=route.Summary)===null||_a===void 0?void 0:_a.RouteBBox,geometry:{type:"MultiLineString",coordinates:processedLegs}}}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * It converts a list of geofences to FeatureCollection with Polygon Features. It can convert geofences both in the
 * response and the request, so it can also help previewing geofences on the map before uploading with PutGeofence or
 * BatchPutGeofence.
 *
 * It will convert:
 *
 * 1. A Polygon Geofence to a Feature with such Polygon
 * 2. A Circle Geofence to a Feature with approximated Polygon with `Center` and `Radius` properties.
 *
 * `GeofenceId` field in the input will be mapped to the id of the corresponding Feature. Fields other then `GeofenceId`
 * and `Geometry` will be mapped into the properties of the corresponding Feature.
 *
 * Any geofence without any of `Polygon` or `Circle` geometry will be skipped.
 *
 * @example Converting a polygon geofence
 *
 * Result of a polygon geofence from GetGeofence:
 *
 * ```json
 * {
 *   "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "Geometry": {
 *     "Polygon": [
 *       [
 *         [1, 2],
 *         [1, 3],
 *         [2, 3],
 *         [1, 2]
 *       ]
 *     ]
 *   },
 *   "Status": "ACTIVE",
 *   "CreateTime": "2023-04-18T21:35:44Z",
 *   "UpdateTime": "2023-04-18T23:20:41Z"
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z"
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           [
 *             [1, 2],
 *             [1, 3],
 *             [2, 3],
 *             [1, 2]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a circle geofence
 *
 * Result of a circle geofence from GetGeofence:
 *
 * ```json
 * {
 *   "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "Geometry": {
 *     "Circle": {
 *       "Center": [1, 2],
 *       "Radius": 10.0
 *     }
 *   },
 *   "Status": "ACTIVE",
 *   "CreateTime": "2023-04-18T21:35:44Z",
 *   "UpdateTime": "2023-04-18T23:20:41Z"
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z",
 *         "Circle": {
 *           "Center": [1, 2],
 *           "Radius": 10.0
 *         }
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           // ... approximated Polygon
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a ListGeofences result with the second result missing the `Polygon` and `Circle` field
 *
 * Result of ListGeofences:
 *
 * ```json
 * {
 *   "Entries": [
 *     {
 *       "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "Geometry": {
 *         "Polygon": [
 *           [
 *             [1, 2],
 *             [1, 3],
 *             [2, 3],
 *             [1, 2]
 *           ]
 *         ]
 *       },
 *       "Status": "ACTIVE",
 *       "CreateTime": "2023-04-18T21:35:44Z",
 *       "UpdateTime": "2023-04-18T23:20:41Z"
 *     },
 *     {
 *       "GeofenceId": "1B4C6411-4A12-4219-4A12-AB5AEE6CD5XE",
 *       "Geometry": {},
 *       "Status": "ACTIVE",
 *       "CreateTime": "2023-04-18T21:35:44Z",
 *       "UpdateTime": "2023-04-18T23:20:41Z"
 *     },
 *     {
 *       "GeofenceId": "7D6C3456-4A12-4219-A99D-CD4AEE6DK4TX",
 *       "Geometry": {
 *         "Circle": {
 *           "Center": [1, 2],
 *           "Radius": 10.0
 *         }
 *       },
 *       "Status": "ACTIVE",
 *       "CreateTime": "2023-04-18T21:35:44Z",
 *       "UpdateTime": "2023-04-18T23:20:41Z"
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z"
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           [
 *             [1, 2],
 *             [1, 3],
 *             [2, 3],
 *             [1, 2]
 *           ]
 *         ]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "id": "7D6C3456-4A12-4219-A99D-CD4AEE6DK4TX",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z",
 *         "Circle": {
 *           "Center": [1, 2],
 *           "Radius": 10.0
 *         }
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           // ... approximated Polygon
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 */function geofencesToFeatureCollection(geofences){if("Entries"in geofences){return toFeatureCollection(geofences.Entries.map(geofence=>geofenceToFeature(geofence)))}else{return toFeatureCollection([geofenceToFeature(geofences)])}}function geofenceToFeature(geofence){if(geofence){const result=convertGeometryToFeature(geofence===null||geofence===void 0?void 0:geofence.Geometry,geofence);if(result){delete result.properties.Geometry;if("GeofenceId"in geofence){result.id=geofence.GeofenceId;delete result.properties.GeofenceId}return result}}}});
