import { FeatureCollection, GeometryCollection, LineString, Point, Polygon } from "geojson";
import { CalculateRoutesResponse, CalculateIsolinesResponse, OptimizeWaypointsResponse, SnapToRoadsResponse } from "@aws-sdk/client-geo-routes";
/**
 * Base options for converting a GeoRoutes response to a GeoJSON FeatureCollection.
 *
 * @group GeoRoutes
 */
export interface BaseGeoRoutesOptions {
    /**
     * Controls the flattening of nested properties.
     *
     * If true, nested properties within the properties field on each Feature will be flattened into a single flat list.
     * This is required when using the properties in MapLibre expressions, as MapLibre doesn't support nested properties.
     *
     * @default true
     */
    flattenProperties?: boolean;
}
/** Options for converting a CalculateRoutesResponse to a GeoJSON FeatureCollection. */
export interface CalculateRoutesResponseOptions extends BaseGeoRoutesOptions {
    /**
     * Optionally creates a LineString Feature for each leg of the route.
     *
     * @default true
     */
    includeLegs?: boolean;
    /**
     * Optionally creates a LineString Feature for each travel step in each leg of the route.
     *
     * @default false
     */
    includeTravelStepGeometry?: boolean;
    /**
     * Optionally creates a LineString Feature for each span in each leg of the route.
     *
     * @default false
     */
    includeSpans?: boolean;
    /**
     * Optionally creates Point Features for the arrival and departure positions of each leg of the route.
     *
     * @default false
     */
    includeLegArrivalDeparturePositions?: boolean;
    /**
     * Optionally creates a Point Feature for the start position of each travel step in each leg of the route.
     *
     * @default false
     */
    includeTravelStepStartPositions?: boolean;
}
/**
 * This converts a CalculateRoutesResponse to an array of GeoJSON FeatureCollections, one for each route in the
 * response. Route responses contain multiple different types of geometry in the response, so the conversion is
 * configurable to choose which features should be in the resulting GeoJSON. Each GeoJSON Feature contains properties
 * from that portion of the response along with any child arrays/structures. It will not contain properties from any
 * parent structures. So for example, with Route->Leg->TravelSteps, a converted Leg feature will contain properties for
 * everything on Leg and everything in TravelSteps, but it won't contain any properties from Route.
 *
 * Each Feature contains a `FeatureType` property that can be used to distinguish between the types of features if
 * multiple are requested during the conversion:
 *
 * - `Leg`: A travel leg of the route. (LineString)
 * - `Span`: A span within a travel leg. (LineString)
 * - `TravelStepGeometry`: A travel step line within a travel leg. (LineString)
 * - `TravelStepStartPosition`: The start position of a travel step within a travel leg. (Point)
 * - `Arrival`: The arrival position of a travel leg. (Point)
 * - `Departure`: The departure position of a travel leg. (Point)
 *
 * Each FeatureCollection may contain a mixture of LineString and Point features, depending on the conversion options
 * provided.
 *
 * Any feature that is missing its geometry in the response or has invalid geometry will throw an Error.
 *
 * @example Drawing a route with travel step dots and hover-over popups at each travel step.
 *
 * ```js
 *         const popup = new maplibregl.Popup({
 *             closeButton: false,
 *             closeOnClick: false
 *         });
 *
 *         // Set up command to calculate route between 2 points
 *         const calculateRouteCommand =
 *             new amazonLocationClient.routes.CalculateRoutesCommand(params);
 *
 *         try {
 *             const response = await client.send(calculateRouteCommand);
 *
 *             const collections = amazonLocationDataConverter.calculateRoutesResponseToFeatureCollections(response, {
 *                 flattenProperties: true,
 *                 includeTravelStepGeometry: true,
 *                 includeLegs: true,
 *                 includeSpans: true,
 *                 includeLegArrivalDeparturePositions: true,
 *                 includeTravelStepStartPositions: true,
 *                 });
 *
 *             if (response.Routes.length > 0) {
 *                 // This is only adding a source for the first route in the returned collection.
 *                 // If all the routes are desired, add sources for each entry in collections[].
 *                 map.addSource("route-0", { type: "geojson", data: collections[0]});
 *
 *                 // This layer filters the GeoJSON to only draw lines of type TravelStepGeometry.
 *                 map.addLayer({
 *                     id: `route-0`,
 *                     type: 'line',
 *                     source: "route-0",
 *                     filter: ['all',
 *                         ['==', ['get', 'FeatureType'], 'TravelStepGeometry'],
 *                     ],
 *                     layout: {
 *                         'line-join': 'round',
 *                         'line-cap': 'round'
 *                     },
 *                     paint: {
 *                         'line-color': '#3887be',
 *                         'line-width': 5,
 *                         'line-opacity': 0.75
 *                     }
 *                 });
 *
 *                 // This layer filters the GeoJSON to only draw points of type TravelStepStartPosition.
 *                 map.addLayer({
 *                     id: "route-0-travelsteps",
 *                     type: "circle",
 *                     source: "route-0",
 *                     filter: ['all',
 *                         ['==', ['get', 'FeatureType'], 'TravelStepStartPosition'],
 *                     ],
 *                     paint: {
 *                         "circle-radius": 6,
 *                         "circle-color": "#B42222",
 *                     },
 *                 });
 *
 *                 // Show a popup on mouseenter with the directions, distance, and duration.
 *                 map.on('mouseenter', 'route-0-travelsteps', (e) => {
 *                     map.getCanvas().style.cursor = 'pointer';
 *
 *                     if (e.features.length > 0) {
 *                         const feature = e.features[0];
 *                         const coordinates = feature.geometry.coordinates.slice();
 *                         let title = e.features[0].properties['Type'] || '';
 *                         if (e.features[0].properties['TurnStepDetails.SteeringDirection']) {
 *                             title = title + ' ' + e.features[0].properties['TurnStepDetails.SteeringDirection'];
 *                         }
 *                         if (e.features[0].properties['RampStepDetails.SteeringDirection']) {
 *                             title = title + ' ' + e.features[0].properties['RampStepDetails.SteeringDirection'];
 *                         }
 *                         if (e.features[0].properties['KeepStepDetails.SteeringDirection']) {
 *                             title = title + ' ' + e.features[0].properties['KeepStepDetails.SteeringDirection'];
 *                         }
 *                         const distance = e.features[0].properties['Distance'] || '';
 *                         const duration = e.features[0].properties['Duration'] || '';
 *
 *                         // Create popup content
 *                         const popupContent = `
 *         <h3>${title}</h3>
 *         <p><strong>Distance:</strong> ${distance}</p>
 *         <p><strong>Duration:</strong> ${duration}</p>
 *       `;
 *
 *                         // Set popup coordinates and content
 *                         popup
 *                           .setLngLat(e.lngLat)
 *                           .setHTML(popupContent)
 *                           .addTo(map);
 *                     }
 *                 });
 *
 *                 // Remove popup on mouseleave
 *                 map.on('mouseleave', 'route-0-travelsteps', () => {
 *                     map.getCanvas().style.cursor = '';
 *                     popup.remove();
 *                 });
 * ```
 */
export declare function calculateRoutesResponseToFeatureCollections(routesResponse: CalculateRoutesResponse, options?: CalculateRoutesResponseOptions): FeatureCollection<Point | LineString>[];
/** Options for converting a CalculateIsolinesResponseOptions to a GeoJSON FeatureCollection. */
export interface CalculateIsolinesResponseOptions extends BaseGeoRoutesOptions {
}
/**
 * This converts a CalculateIsolineResponse to a GeoJSON FeatureCollection which contains one Feature for each isoline
 * in the response. Isolines can contain both polygons for isoline regions and lines for connectors between regions
 * (such as ferry travel), so each Feature contains either a GeometryCollection with a mix of Polygons and LineStrings
 * or a single Polygon.
 *
 * Any feature that is missing its geometry in the response or has invalid geometry will throw an Error.
 *
 * @example Drawing an isolines response with multiple isoline regions and connector lines.
 *
 * ```js
 *         // Set up command to calculate isolines
 *         const calculateIsolinesCommand =
 *             new amazonLocationClient.routes.CalculateIsolinesCommand(params);
 *
 *         try {
 *             const response = await client.send(calculateIsolinesCommand);
 *
 *             const collection = amazonLocationDataConverter.calculateIsolinesResponseToFeatureCollection(response, {
 *                 flattenProperties: true
 *                 });
 *
 *             // Add the results as a GeoJSON source
 *             map.addSource('isolines', { type: 'geojson', data: collection});
 *
 *             // Add a layer for drawing the isoline polygon regions.
 *             // It's important to filter the geometry type to polygons, because any connector lines
 *             // in the results would still try to draw a filled region on one side of the line.
 *             // These are being drawn as partially translucent so that overlapping isoline regions
 *             // additively get more opaque.
 *             map.addLayer({
 *                 id: 'isolines',
 *                 type: 'fill',
 *                 source: 'isolines',
 *                 layout: {
 *                 },
 *                 paint: {
 *                     "fill-color": "#3887be",
 *                     'fill-opacity': 0.6
 *                 },
 *                 'filter': ['==', ['geometry-type'], 'Polygon']
 *             });
 *
 *             // Draw any connector lines that exist in the result.
 *             // It's important to filter the geometry type to LineStrings. Otherwise, any polygons
 *             // would have their outlines drawn here as well.
 *             map.addLayer({
 *                 id: 'isolines-connector',
 *                 type: 'line',
 *                 source: 'isolines',
 *                 layout: {
 *                     'line-join': 'round',
 *                     'line-cap': 'round'
 *                 },
 *                 paint: {
 *                     'line-color': '#FF0000',  // Default color
 *                     'line-width': 3,
 *                     'line-opacity': 0.75
 *                 },
 *                 'filter': ['==', ['geometry-type'], 'LineString']
 *             });
 * ```
 */
export declare function calculateIsolinesResponseToFeatureCollection(isolinesResponse: CalculateIsolinesResponse, options?: CalculateIsolinesResponseOptions): FeatureCollection<GeometryCollection<Polygon | LineString> | Polygon>;
/** Options for converting an OptimizeWaypointsResponse to a GeoJSON FeatureCollection. */
export interface OptimizeWaypointsResponseOptions extends BaseGeoRoutesOptions {
}
/**
 * This converts an OptimizeWaypointsResponse to a GeoJSON FeatureCollection which contains one Feature for each
 * waypoint in the response. The response can contain either impeding waypoints or optimized waypoints. They will both
 * get added into the GeoJSON with a FeatureType property of ImpedingWaypoint or OptimizedWaypoint respectively.
 *
 * @example Drawing labels underneath the waypoints that show the optimized order.
 *
 * ```js
 *         // Set up command to optimize waypoints
 *         const optimizeWaypointsCommand =
 *             new amazonLocationClient.routes.OptimizeWaypointsCommand(params);
 *
 *         try {
 *             const response = await client.send(optimizeWaypointsCommand);
 *
 *             const collection = amazonLocationDataConverter.optimizeWaypointsResponseToFeatureCollection(response, {
 *                 flattenProperties: true
 *                 });
 *
 *             // Add the GeoJSON collection as a source to the map
 *             map.addSource('waypoints', { type: 'geojson', data: collection});
 *
 *             // Add a layer that draws the numeric id of each point underneath the location.
 *             map.addLayer({
 *                 id: 'waypoint-numbers',
 *                 type: 'symbol',
 *                 source: 'waypoints',
 *                 layout: {
 *                     'text-field': ['id'],
 *                     "text-font": ["Amazon Ember Regular"],
 *                     'text-size': 18,
 *                     'text-offset': [0, 1.5],
 *                     'text-anchor': 'bottom'
 *                 },
 *                 paint: {
 *                     'text-color': '#000000',
 *                     'text-halo-color': '#FFFFFF',
 *                     'text-halo-width': 1
 *                 },
 *             });
 * ```
 */
export declare function optimizeWaypointsResponseToFeatureCollection(waypointsResponse: OptimizeWaypointsResponse, options?: OptimizeWaypointsResponseOptions): FeatureCollection<Point>;
/** Options for converting an SnapToRoadsResponseOptions to a GeoJSON FeatureCollection. */
export interface SnapToRoadsResponseOptions extends BaseGeoRoutesOptions {
    /**
     * Optionally creates a LineString Feature for the snapped route geometry.
     *
     * @default true
     */
    includeSnappedGeometry?: boolean;
    /**
     * Optionally creates a Point Feature for each original trace point submitted.
     *
     * @default false
     */
    includeSnappedTracePointOriginalPositions?: boolean;
    /**
     * Optionally creates a Point Feature for each snapped trace point.
     *
     * @default false
     */
    includeSnappedTracePointSnappedPositions?: boolean;
    /**
     * Optionally creates a LineString Feature containing a line from the submitted trace point to the snapped trace point
     * for each submitted point.
     *
     * @default false
     */
    includeOriginalToSnappedPositionLines?: boolean;
}
/**
 * This converts a SnapToRoadsResponse to a GeoJSON FeatureCollection. The FeatureCollection may optionally contain any
 * combination of the following:
 *
 * - A LineString Feature with the snapped route geometry, if includeSnappedGeometry is true.
 * - Point Features for each original trace point, if includeSnappedTracePointOriginalPositions is true.
 * - Point Features for each snapped trace point, if includeSnappedTracePointSnappedPositions is true.
 * - LineString Features for each snap line (line from original to snapped trace point), if
 *   includeOriginalToSnappedPositionLines is true.
 *
 * Each Feature contains a `FeatureType` property that can be used to distinguish between the types of features if
 * multiple are requested during the conversion:
 *
 * - `SnappedGeometry`: The snapped route geometry.
 * - `SnappedTracePointOriginalPosition`: The original submitted trace point.
 * - `SnappedTracePointSnappedPosition`: The snapped trace point.
 * - `OriginalToSnappedPositionLine`: A line from the original trace point to the corresponding snapped trace point.
 *
 * @example Drawing the snapped route, dots for each snapped trace point, and lines from the original trace points to
 * the snapped trace points.
 *
 * ```js
 *         // Set up command to optimize waypoints
 *         const snapToRoadsCommand =
 *             new amazonLocationClient.routes.SnapToRoadsCommand(params);
 *
 *         try {
 *             const response = await client.send(snapToRoadsCommand);
 *
 *             const collection = amazonLocationDataConverter.snapToRoadsResponseToFeatureCollection(response, {
 *                 flattenProperties: true,
 *                 includeSnappedGeometry: true,
 *                 includeSnappedTracePointOriginalPositions: true,
 *                 includeSnappedTracePointSnappedPositions: true,
 *                 includeOriginalToSnappedPositionLines: true
 *                 });
 *
 *             // Add the GeoJSON results as a source to the map.
 *             map.addSource('snapped', { type: 'geojson', data: collection});
 *
 *             // Add a layer that only draws the snapped route calculated from the trace points.
 *             // This is done by filtering the FeatureType to SnappedGeometry.
 *             map.addLayer({
 *                 id: 'SnappedGeometry',
 *                 type: 'line',
 *                 source: 'snapped',
 *                 layout: {
 *                     'line-join': 'round',
 *                     'line-cap': 'round'
 *                 },
 *                 paint: {
 *                     'line-color': '#3887be',  // Default color
 *                     'line-width': 3,
 *                     'line-opacity': 0.75
 *                 },
 *                 filter: ['==', ['get', 'FeatureType'], 'SnappedGeometry']
 *             });
 *
 *             // Add a layer that only draws the lines from the submitted points to the snapped points.
 *             // We draw these separately so that we can draw these in a different color than the route.
 *             // Alternatively, we could've used a case statement on the line-color to switch it.
 *             map.addLayer({
 *                 id: 'snappedLines',
 *                 type: 'line',
 *                 source: 'snapped',
 *                 layout: {
 *                     'line-join': 'round',
 *                     'line-cap': 'round'
 *                 },
 *                 paint: {
 *                     'line-color': '#FF0000',  // Default color
 *                     'line-width': 3,
 *                     'line-opacity': 0.75
 *                 },
 *                 filter: ['==', ['get', 'FeatureType'], 'OriginalToSnappedPositionLine']
 *             });
 *
 *             // Add a layer that only draws circles at the snapped trace points.
 *             map.addLayer({
 *                 id: 'snappedTracePoints',
 *                 type: 'circle',
 *                 source: 'snapped',
 *                 filter: ['all',
 *                     ['==', ['get', 'FeatureType'], 'SnappedTracePointSnappedPosition']
 *                 ],
 *                 paint: {
 *                     'circle-radius': 5,
 *                     'circle-color': '#FF0000'
 *                 }
 *             });
 * ```
 */
export declare function snapToRoadsResponseToFeatureCollection(snapToRoadsResponse: SnapToRoadsResponse, options?: SnapToRoadsResponseOptions): FeatureCollection<Point | LineString>;
