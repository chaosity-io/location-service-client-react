// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { flattenProperties, emptyFeatureCollection } from "./utils";
const defaultBaseGeoPlacesOptions = {
    flattenProperties: true,
};
const defaultGetPlaceResponseOptions = defaultBaseGeoPlacesOptions;
/**
 * Convert GetPlaceResponse responses from our standalone Places SDK to a FeatureCollection with a Point Feature. Each
 * Feature is given a locally-unique integer id for easier use with MapLibre. `Position` is extracted as the location
 * for the Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If the result doesn't contain location information, the output will be an empty FeatureCollection.
 *
 * @example Drawing the result of GetPlaceCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.GetPlaceCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.getPlaceResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response GetPlaceResponse from the GetPlace API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */
export function getPlaceResponseToFeatureCollection(response, options) {
    // Set any options that weren't passed in to the defaults.
    options = Object.assign(Object.assign({}, defaultGetPlaceResponseOptions), options);
    const collection = emptyFeatureCollection();
    // Create a single feature in the feature collection with the entire response in the properties except
    // for Position, since that becomes the feature's geometry coordinates.
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { Position } = response, properties = __rest(response, ["Position"]);
    addGeoJsonPointFeature(collection, response.Position, properties, options.flattenProperties);
    return collection;
}
const defaultGeocodeResponseOptions = defaultBaseGeoPlacesOptions;
/**
 * Convert GeocodeResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features. Each
 * item in the `ResultItems` list is extracted as its own feature. `Position` is extracted as the location for the Point
 * Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of GeocodeCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.GeocodeCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.geocodeResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response GeocodeResponse from the Geocode API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */
export function geocodeResponseToFeatureCollection(response, options) {
    var _a;
    // Set any options that weren't passed in to the defaults.
    options = Object.assign(Object.assign({}, defaultGeocodeResponseOptions), options);
    const collection = emptyFeatureCollection();
    for (const result of (_a = response.ResultItems) !== null && _a !== void 0 ? _a : []) {
        // Create a single feature in the feature collection for each result with the entire result in the properties except
        // for Position, since that becomes the feature's geometry coordinates.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { Position } = result, properties = __rest(result, ["Position"]);
        addGeoJsonPointFeature(collection, result.Position, properties, options.flattenProperties);
    }
    return collection;
}
const defaultReverseGeocodeResponseOptions = defaultBaseGeoPlacesOptions;
/**
 * Convert ReverseGeocodeResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features.
 * Each item in the `ResultItems` list is extracted as its own feature. `Position` is extracted as the location for the
 * Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of ReverseGeocodeCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.ReverseGeocodeCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.reverseGeocodeResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response ReverseGeocodeResponse from the ReverseGeocode API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */
export function reverseGeocodeResponseToFeatureCollection(response, options) {
    var _a;
    // Set any options that weren't passed in to the defaults.
    options = Object.assign(Object.assign({}, defaultReverseGeocodeResponseOptions), options);
    const collection = emptyFeatureCollection();
    for (const result of (_a = response.ResultItems) !== null && _a !== void 0 ? _a : []) {
        // Create a single feature in the feature collection for each result with the entire result in the properties except
        // for Position, since that becomes the feature's geometry coordinates.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { Position } = result, properties = __rest(result, ["Position"]);
        addGeoJsonPointFeature(collection, result.Position, properties, options.flattenProperties);
    }
    return collection;
}
const defaultSearchNearbyResponseOptions = defaultBaseGeoPlacesOptions;
/**
 * Convert SearchNearbyResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features.
 * Each item in the `ResultItems` list is extracted as its own feature. `Position` is extracted as the location for the
 * Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of SearchNearbyCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.SearchNearbyCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.searchNearbyResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response SearchNearbyResponse from the SearchNearby API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */
export function searchNearbyResponseToFeatureCollection(response, options) {
    var _a;
    // Set any options that weren't passed in to the defaults.
    options = Object.assign(Object.assign({}, defaultSearchNearbyResponseOptions), options);
    const collection = emptyFeatureCollection();
    for (const result of (_a = response.ResultItems) !== null && _a !== void 0 ? _a : []) {
        // Create a single feature in the feature collection for each result with the entire result in the properties except
        // for Position, since that becomes the feature's geometry coordinates.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { Position } = result, properties = __rest(result, ["Position"]);
        addGeoJsonPointFeature(collection, result.Position, properties, options.flattenProperties);
    }
    return collection;
}
const defaultSearchTextResponseOptions = defaultBaseGeoPlacesOptions;
/**
 * Convert SearchTextResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features.
 * Each item in the `ResultItems` list is extracted as its own feature. `Position` is extracted as the location for the
 * Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of SearchTextCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.SearchTextCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.searchTextResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response SearchTextResponse from the SearchText API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */
export function searchTextResponseToFeatureCollection(response, options) {
    var _a;
    // Set any options that weren't passed in to the defaults.
    options = Object.assign(Object.assign({}, defaultSearchTextResponseOptions), options);
    const collection = emptyFeatureCollection();
    for (const result of (_a = response.ResultItems) !== null && _a !== void 0 ? _a : []) {
        // Create a single feature in the feature collection for each result with the entire result in the properties except
        // for Position, since that becomes the feature's geometry coordinates.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { Position } = result, properties = __rest(result, ["Position"]);
        addGeoJsonPointFeature(collection, result.Position, properties, options.flattenProperties);
    }
    return collection;
}
const defaultSuggestResponseOptions = defaultBaseGeoPlacesOptions;
/**
 * Convert SuggestResponse responses from our standalone Places SDK to a FeatureCollection with a Point Features. Each
 * item in the `ResultItems` list is extracted as its own feature. `Place.Position` is extracted as the location for the
 * Point Feature. All other properties in the response are mapped into the Feature properties.
 *
 * If a result item doesn't contain location information, it will not appear in the FeatureCollection.
 *
 * @example Drawing the result of SuggestCommand:
 *
 * ```js
 * // ...
 * const command = new amazonLocationClient.SuggestCommand(params);
 *
 * try {
 *   const response = await client.send(command);
 *   if (response.error) {
 *     // error handling
 *   } else {
 *     const featureCollection = amazonLocationDataConverter.suggestResponseToFeatureCollection(response);
 *     map.addSource("search-result", { type: "geojson", data: featureCollection });
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * } catch (error) {}
 * // ...
 * ```
 *
 * @param response SuggestResponse from the SearchText API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 * @group GeoPlaces
 */
export function suggestResponseToFeatureCollection(response, options) {
    var _a, _b, _c;
    // Set any options that weren't passed in to the defaults.
    options = Object.assign(Object.assign({}, defaultSuggestResponseOptions), options);
    const collection = emptyFeatureCollection();
    for (const result of (_a = response.ResultItems) !== null && _a !== void 0 ? _a : []) {
        // Create a single feature in the feature collection for each result with the entire result in the properties except
        // for Place.Position, since that becomes the feature's geometry coordinates.
        // We use structuredClone here to make a deep copy to ensure that deleting from the nested
        // Place struct doesn't change the original value.
        const properties = structuredClone(result);
        (_b = properties.Place) === null || _b === void 0 ? true : delete _b.Position;
        addGeoJsonPointFeature(collection, (_c = result.Place) === null || _c === void 0 ? void 0 : _c.Position, properties, options.flattenProperties);
    }
    return collection;
}
/**
 * Creates a GeoJSON feature from a given id, coordinates, and Response structure.
 *
 * @param collection The FeatureCollection to add the feature to.
 * @param coordinates The coordinates to use for the Point, extracted from the Response structure.
 * @param properties The Response structure with the placeId and coordinates removed from it. The placeId and
 *   coordinates are expected to be removed because they would be redundant data since they already appear as the id and
 *   the geometry coordinates of the Point Feature.
 * @param flatten Whether to flatten the properties or not. Defaults to true.
 * @returns A GeoJSON Point Feature of the Response object, or null if no coordinates were present.
 */
function addGeoJsonPointFeature(collection, coordinates, properties, flatten) {
    if (coordinates) {
        // Create a shallow copy of the passed-in properties and remove "$metadata", which can appear
        // in Response objects from the AWS SDK. Since $metadata is only metadata about the API call and
        // not a part of the Response data, we don't want or need it to appear in the generated GeoJSON.
        const propertiesClone = Object.assign({}, properties);
        delete propertiesClone["$metadata"];
        collection.features.push({
            type: "Feature",
            id: collection.features.length,
            properties: flatten ? flattenProperties(propertiesClone) : propertiesClone,
            geometry: {
                type: "Point",
                coordinates: coordinates,
            },
        });
    }
}
