(function(global,factory){if(typeof define==="function"&&define.amd){define("polyline",["exports"],factory)}else if(typeof exports!=="undefined"){factory(exports)}else{var mod={exports:{}};factory(mod.exports);global.polyline=mod.exports}})(typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:this,function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:true});_exports.ThirdDimension=_exports.CompressionAlgorithm=void 0;_exports.decodeToLineString=decodeToLineString;_exports.decodeToLineStringFeature=decodeToLineStringFeature;_exports.decodeToLngLatArray=decodeToLngLatArray;_exports.decodeToPolygon=decodeToPolygon;_exports.decodeToPolygonFeature=decodeToPolygonFeature;_exports.encodeFromLngLatArray=encodeFromLngLatArray;_exports.getCompressionAlgorithm=getCompressionAlgorithm;_exports.setCompressionAlgorithm=setCompressionAlgorithm;function _callSuper(t,o,e){return o=_getPrototypeOf(o),_possibleConstructorReturn(t,_isNativeReflectConstruct()?Reflect.construct(o,e||[],_getPrototypeOf(t).constructor):o.apply(t,e))}function _possibleConstructorReturn(t,e){if(e&&("object"==_typeof(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(t)}function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(t){}return(_isNativeReflectConstruct=function _isNativeReflectConstruct(){return!!t})()}function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_setPrototypeOf(t,e)}function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=_unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var _n=0,F=function F(){};return{s:F,n:function n(){return _n>=r.length?{done:!0}:{done:!1,value:r[_n++]}},e:function e(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function s(){t=t.call(r)},n:function n(){var r=t.next();return a=r.done,r},e:function e(r){u=!0,o=r},f:function f(){try{a||null==t["return"]||t["return"]()}finally{if(u)throw o}}}}function _slicedToArray(r,e){return _arrayWithHoles(r)||_iterableToArrayLimit(r,e)||_unsupportedIterableToArray(r,e)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return _arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(r,a):void 0}}function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t["return"]&&(u=t["return"](),Object(u)!==u))return}finally{if(o)throw n}}return a}}function _arrayWithHoles(r){if(Array.isArray(r))return r}function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,_toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}function _toPropertyKey(t){var i=_toPrimitive(t,"string");return"symbol"==_typeof(i)?i:i+""}function _toPrimitive(t,r){if("object"!=_typeof(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// Third party license at
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
/** Defines the default encoding precision for coordinates */var DefaultPrecision=6;/** The version of flexible-polyline that's supported by this implementation */var FlexiblePolylineFormatVersion=1;/** Defines the set of compression algorithms that are supported by this library. */var CompressionAlgorithm;(function(CompressionAlgorithm){/** Encoder/decoder for the [Flexible Polyline](https://github.com/heremaps/flexible-polyline) format. */CompressionAlgorithm[CompressionAlgorithm["FlexiblePolyline"]=0]="FlexiblePolyline";/** Encoder/decoder for the [Encoded Polyline Algorithm Format](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
     * with 5 bits of precision.
     */CompressionAlgorithm[CompressionAlgorithm["Polyline5"]=1]="Polyline5";/** Encoder/decoder for the [Encoded Polyline Algorithm Format](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
     * with 6 bits of precision.
     */CompressionAlgorithm[CompressionAlgorithm["Polyline6"]=2]="Polyline6"})(CompressionAlgorithm||(_exports.CompressionAlgorithm=CompressionAlgorithm={}));/** Defines how to interpret a third dimension value if it exists. */var ThirdDimension;(function(ThirdDimension){/** No third dimension specified */ThirdDimension[ThirdDimension["None"]=0]="None";/** Third dimension is level */ThirdDimension[ThirdDimension["Level"]=1]="Level";/** Third dimension is altitude (height above the Earth's surface) */ThirdDimension[ThirdDimension["Altitude"]=2]="Altitude";/** Third dimension is elevation (height of the Earth's surface relative to the reference geoid) */ThirdDimension[ThirdDimension["Elevation"]=3]="Elevation"})(ThirdDimension||(_exports.ThirdDimension=ThirdDimension={}));// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// DataCompressor is an abstract base class that defines the interface for
// encoding/decoding compressed coordinate arrays. The coordinate arrays represent either
// LineString ("polyline") or Polygon geometry.
// To make this compressed data easy to use with MapLibre, DataCompressor provides
// methods for decoding the data into different types of GeoJSON outputs:
//  - decodeToLineStringFeature / decodeToPolygonFeature:
//      These produce a GeoJSON Feature object that can be directly passed into MapLibre as a geojson source.
//  - decodeToLineString / decodeToPolygon:
//      These produce a GeoJSON Geometry object that can be manually assembled into a Feature to pass
//      into MapLibre as a geojson source.
// Concrete implementations of this class are expected to implement the following APIs:
// - compressLngLatArray(lngLatArray, compressionParameters) -> compressedData
// - decompressLngLatArray(compressedData) -> [lngLatArray, compressionParameters]
var DataCompressor=/*#__PURE__*/function(){function DataCompressor(){_classCallCheck(this,DataCompressor)}return _createClass(DataCompressor,[{key:"polygonIsCounterClockwise",value:// Helper method to determine whether the polygon is wound in CCW (counterclockwise) or CW (clockwise) order.
function polygonIsCounterClockwise(lngLatArray){// If the data isn't a polygon, then it can't be a counter-clockwise polygon.
// (A polygon requires at least 3 unique points and a 4th last point that matches the first)
if(lngLatArray.length<4){return false}// To determine if a polygon has a counterclockwise winding order, all we need to
// do is calculate the area of the polygon.
// If the area is positive, it's counterclockwise.
// If the area is negative, it's clockwise.
// If the area is 0, it's neither, so we'll still return false for counterclockwise.
// This implementation currently assumes that only 2D winding order is important and
// ignores any optional third dimension.
var area=0;for(var idx=0;idx<lngLatArray.length-1;idx++){var x1=lngLatArray[idx][0];var y1=lngLatArray[idx][1];var x2=lngLatArray[idx+1][0];var y2=lngLatArray[idx+1][1];area+=x1*y2-x2*y1}// If we needed the actual area value, we should divide by 2 here, but since we only
// need to check the sign, we can skip the division.
return area>0}// Helper method to determine if two LngLat positions are equivalent within a given epsilon range.
},{key:"positionsAreEquivalent",value:function positionsAreEquivalent(pos1,pos2){// Verify that the two positions are equal within an epsilon.
// This epsilon was picked because most compressed data uses <= 6 digits of precision,
// so this epsilon is large enough to detect intentionally different data, and small
// enough to detect equivalency for values that just have compression artifact drift.
var epsilon=0.000001;if(pos1.length!=pos2.length){return false}// Loop through longitude, latitude, and optional 3rd dimension to make sure each one is equivalent.
for(var idx=0;idx<pos1.length;idx++){if(Math.abs(pos1[idx]-pos2[idx])>=epsilon){return false}}return true}},{key:"decodeLineString",value:function decodeLineString(compressedData){var _this$decompressLngLa=this.decompressLngLatArray(compressedData),_this$decompressLngLa2=_slicedToArray(_this$decompressLngLa,2),decodedLine=_this$decompressLngLa2[0],compressionParameters=_this$decompressLngLa2[1];// Validate that the result is a valid GeoJSON LineString per the RFC 7946 GeoJSON spec:
// "The 'coordinates' member is an array of two or more positions"
if(decodedLine.length<2){throw Error("Invalid LineString. LineStrings must contain 2 or more positions. It contains ".concat(decodedLine.length," positions."))}return[{type:"LineString",coordinates:decodedLine},compressionParameters]}},{key:"decodePolygon",value:function decodePolygon(compressedData){var decodedPolygon=[];var shouldBeCounterclockwise=true;// The first ring of a polygon should be counterclockwise
var compressionParameters={};var _iterator=_createForOfIteratorHelper(compressedData),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var ring=_step.value;var _this$decompressLngLa3=this.decompressLngLatArray(ring),_this$decompressLngLa4=_slicedToArray(_this$decompressLngLa3,2),decodedRing=_this$decompressLngLa4[0],ringCompressionParameters=_this$decompressLngLa4[1];// Validate that the result is a valid GeoJSON Polygon linear ring per the RFC 7946 GeoJSON spec.
// 1. "A linear ring is a closed LineString with 4 or more positions."
if(decodedRing.length<4){throw Error("Invalid polygon. Polygons must contain 4 or more positions. It contains ".concat(decodedRing.length," positions. Consider decoding as a LineString."))}// 2. "The first and last positions are equivalent, and they MUST contain identical values;
//     their representation SHOULD also be identical."
// We validate equivalency within a small epsilon.
if(!this.positionsAreEquivalent(decodedRing[0],decodedRing[decodedRing.length-1])){throw Error("Invalid polygon. The first and last positions must contain identical values. The values are ".concat(decodedRing[0],", ").concat(decodedRing.at(-1),". Consider decoding as a LineString."))}// 3. "A linear ring MUST follow the right-hand rule with respect to the area it bounds,
//     i.e., exterior rings are counterclockwise, and holes are clockwise."
// "Note: the [GJ2008] specification did not discuss linear ring winding
//    order.  For backwards compatibility, parsers SHOULD NOT reject
//    Polygons that do not follow the right-hand rule."
// "For Polygons with more than one of these rings, the first MUST be
//       the exterior ring, and any others MUST be interior rings.  The
//       exterior ring bounds the surface, and the interior rings (if
//       present) bound holes within the surface."
// With all this taken together, we should enforce the winding order as opposed to just
// validating it.
if(shouldBeCounterclockwise!=this.polygonIsCounterClockwise(decodedRing)){decodedRing.reverse()}decodedPolygon.push(decodedRing);// Set compressionParameter metadata to whatever the last compression parameters were that were used.
// This may need to have more complicated logic at some point if different rings have different compression
// parameters and we want to capture all of them.
compressionParameters=ringCompressionParameters;// All rings after the first should be clockwise.
shouldBeCounterclockwise=false}}catch(err){_iterator.e(err)}finally{_iterator.f()}return[{type:"Polygon",coordinates:decodedPolygon},compressionParameters]}},{key:"compressionParametersToGeoJsonProperties",value:function compressionParametersToGeoJsonProperties(parameters){switch(parameters.thirdDimension){case ThirdDimension.Level:return{precision:parameters.precisionLngLat,thirdDimensionPrecision:parameters.precisionThirdDimension,thirdDimensionType:"level"};case ThirdDimension.Elevation:return{precision:parameters.precisionLngLat,thirdDimensionPrecision:parameters.precisionThirdDimension,thirdDimensionType:"elevation"};case ThirdDimension.Altitude:return{precision:parameters.precisionLngLat,thirdDimensionPrecision:parameters.precisionThirdDimension,thirdDimensionType:"altitude"};default:return{precision:parameters.precisionLngLat}}}},{key:"encodeFromLngLatArray",value:function encodeFromLngLatArray(lngLatArray,parameters){return this.compressLngLatArray(lngLatArray,parameters)}},{key:"decodeToLngLatArray",value:function decodeToLngLatArray(compressedData){var _this$decompressLngLa5=this.decompressLngLatArray(compressedData),_this$decompressLngLa6=_slicedToArray(_this$decompressLngLa5,1),decodedLngLatArray=_this$decompressLngLa6[0];return decodedLngLatArray}},{key:"decodeToLineString",value:function decodeToLineString(compressedData){var _this$decodeLineStrin=this.decodeLineString(compressedData),_this$decodeLineStrin2=_slicedToArray(_this$decodeLineStrin,1),lineString=_this$decodeLineStrin2[0];return lineString}},{key:"decodeToPolygon",value:function decodeToPolygon(compressedData){var _this$decodePolygon=this.decodePolygon(compressedData),_this$decodePolygon2=_slicedToArray(_this$decodePolygon,1),polygon=_this$decodePolygon2[0];return polygon}},{key:"decodeToLineStringFeature",value:function decodeToLineStringFeature(compressedData){var _this$decodeLineStrin3=this.decodeLineString(compressedData),_this$decodeLineStrin4=_slicedToArray(_this$decodeLineStrin3,2),lineString=_this$decodeLineStrin4[0],compressionParameters=_this$decodeLineStrin4[1];return{type:"Feature",geometry:lineString,properties:this.compressionParametersToGeoJsonProperties(compressionParameters)}}},{key:"decodeToPolygonFeature",value:function decodeToPolygonFeature(compressedData){var _this$decodePolygon3=this.decodePolygon(compressedData),_this$decodePolygon4=_slicedToArray(_this$decodePolygon3,2),polygon=_this$decodePolygon4[0],compressionParameters=_this$decodePolygon4[1];return{type:"Feature",geometry:polygon,properties:this.compressionParametersToGeoJsonProperties(compressionParameters)}}}])}();// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// This class implements both the Encoded Polyline Algorithm Format
// (https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
// and the Flexible-Polyline variation of the algorithm (https://github.com/heremaps/flexible-polyline).
// This implementation has two differences to improve usability:
// - It uses well-defined rounding to ensure deterministic results across all programming languages.
//   The Flexible-Polyline algorithm definition says to use the rounding rules of the programming
//   language, but this can cause inconsistent rounding depending on what language happens to be used
//   on both the encoding and decoding sides.
// - It caps the max encoding/decoding precision to 11 decimal places (1 micrometer), because 12+ places can
//   lose precision when using 64-bit floating-point numbers to store integers.
var PolylineEncoder=/*#__PURE__*/function(){function PolylineEncoder(encodingTable,includeHeader){_classCallCheck(this,PolylineEncoder);this.encodingTable=encodingTable;this.includeHeader=includeHeader}// The original polyline algorithm supposedly uses "round to nearest, ties away from 0"
// for its rounding rule. Flexible-polyline uses the rounding rules of the implementing
// language. Our generalized implementation will use the "round to nearest, ties away from 0"
// rule for all languages to keep the encoding deterministic across implementations.
return _createClass(PolylineEncoder,[{key:"polylineRound",value:function polylineRound(value){return Math.sign(value)*Math.floor(Math.abs(value)+0.5)}},{key:"encode",value:function encode(lngLatArray,precision){var _this=this;var thirdDim=arguments.length>2&&arguments[2]!==undefined?arguments[2]:ThirdDimension.None;var thirdDimPrecision=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;if(precision<0||precision>11){throw Error("Only precision values of 0-11 decimal digits are supported.")}if(!Object.values(ThirdDimension).includes(+thirdDim)){throw Error("thirdDim is an invalid ThirdDimension value.")}if(thirdDimPrecision<0||thirdDimPrecision>11){throw Error("Only thirdDimPrecision values of 0-11 decimal digits are supported.")}if(!lngLatArray.length){return""}var numDimensions=thirdDim?3:2;// The data will either encode lat/lng or lat/lng/z values.
// precisionMultipliers are the multipliers needed to convert the values
// from floating-point to scaled integers.
var precisionMultipliers=[Math.pow(10,precision),Math.pow(10,precision),Math.pow(10,thirdDimPrecision)];// While encoding, we want to switch from lng/lat/z to lat/lng/z, so this index tells us
// what index to grab from the input coordinate when encoding each dimension.
var inputDimensionIndex=[1,0,2];// maxAllowedValues are the maximum absolute values allowed for lat/lng/z. This is used for
// error-checking the coordinate values as they're being encoded.
var maxAllowedValues=[90,180,Infinity];// Encoded values are deltas from the previous coordinate values, so track the previous lat/lng/z values.
var lastScaledCoordinate=[0,0,0];var output="";// Flexible-polyline starts with an encoded header that contains precision and dimension metadata.
if(this.includeHeader){output=this.encodeHeader(precision,thirdDim,thirdDimPrecision)}lngLatArray.forEach(function(coordinate){if(coordinate.length!=numDimensions){throw Error("Invalid input. All coordinates need to have the same number of dimensions.")}for(var dimension=0;dimension<numDimensions;dimension++){// Even though our input data is in lng/lat/z order, this is where we grab them in
// lat/lng/z order for encoding.
var inputValue=coordinate[inputDimensionIndex[dimension]];// While looping through, also verify the input data is valid
if(Math.abs(inputValue)>maxAllowedValues[dimension]){throw Error("Invalid input. Input coordinates must contain valid lng/lat coordinate data. Found ".concat(coordinate,"."))}// Scale the value based on the number of digits of precision, encode the delta between
// it and the previous value to the output, and track it as the previous value for encoding
// the next delta.
var scaledValue=_this.polylineRound(inputValue*precisionMultipliers[dimension]);output+=_this.encodeSignedValue(scaledValue-lastScaledCoordinate[dimension]);lastScaledCoordinate[dimension]=scaledValue}});return output}},{key:"encodeHeader",value:function encodeHeader(precision,thirdDim,thirdDimPrecision){// Combine all the metadata about the encoded data into a single value for the header.
var metadataValue=thirdDimPrecision<<7|thirdDim<<4|precision;return this.encodeUnsignedValue(FlexiblePolylineFormatVersion)+this.encodeUnsignedValue(metadataValue)}// Given a single input unsigned scaled value, this encodes into a series of
// ASCII characters. The flexible-polyline algorithm uses this directly to encode
// the header bytes, since those are known not to need a sign bit.
},{key:"encodeUnsignedValue",value:function encodeUnsignedValue(value){var encodedString="";var remainingValue=value;// Loop through each 5-bit chunk in the value, add a 6th bit if there
// will be additional chunks, and encode to an ASCII value.
while(remainingValue>31){var chunk=remainingValue&31|32;encodedString+=this.encodingTable[chunk];remainingValue>>=5}// For the last chunk, set the 6th bit to 0 (since there are no more chunks) and encode it.
return encodedString+this.encodingTable[remainingValue]}// Given a single input signed scaled value, this encodes into a series of
// ASCII characters.
},{key:"encodeSignedValue",value:function encodeSignedValue(value){var unsignedValue=value;// Shift the value over by 1 bit to make room for the sign bit at the end.
unsignedValue<<=1;// If the input value is negative, flip all the bits, including the sign bit.
if(value<0){unsignedValue=~unsignedValue}return this.encodeUnsignedValue(unsignedValue)}}])}();// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// This class implements both the Encoded Polyline Algorithm Format
// (https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
// and the Flexible-Polyline variation of the algorithm (https://github.com/heremaps/flexible-polyline).
// This implementation has two differences to improve usability:
// - It uses well-defined rounding to ensure deterministic results across all programming languages.
// - It caps the max encoding/decoding precision to 11 decimal places (1 micrometer), because 15 places will
//   lose precision when using 64-bit floating-point numbers.
var PolylineDecoder=/*#__PURE__*/function(){function PolylineDecoder(decodingTable,containsHeader){_classCallCheck(this,PolylineDecoder);this.decodingTable=decodingTable;this.containsHeader=containsHeader}// Given an encoded string and a starting index, this decodes a single encoded signed value.
// The decoded value will be an integer that still needs the decimal place moved over based
// on the number of digits of encoded precision.
return _createClass(PolylineDecoder,[{key:"decodeSignedValue",value:function decodeSignedValue(encoded,startIndex){// decode an unsigned value
var _this$decodeUnsignedV=this.decodeUnsignedValue(encoded,startIndex),_this$decodeUnsignedV2=_slicedToArray(_this$decodeUnsignedV,2),unsignedValue=_this$decodeUnsignedV2[0],nextIndex=_this$decodeUnsignedV2[1];// If the unsigned value has a 1 encoded in its least significant bit,
// it's negative, so flip the bits.
var signedValue=unsignedValue;if(unsignedValue&1){signedValue=~signedValue}// Shift the result by one to remove the encoded sign bit.
signedValue>>=1;return[signedValue,nextIndex]}// Given an encoded string and a starting index, this decodes a single encoded
// unsigned value. The flexible-polyline algorithm uses this directly to decode
// the header bytes, since those are encoded without the sign bit as the header
// values are known to be unsigned (which saves 2 bits).
},{key:"decodeUnsignedValue",value:function decodeUnsignedValue(encoded,startIndex){var result=0;var shift=0;var index=startIndex;// For each ASCII character, get the 6-bit (0x00 - 0x3F) value that
// it represents. Shift the accumulated result by 5 bits, add the new
// 5-bit chunk to the bottom, and keep going for as long as the 6th bit
// is set.
while(index<encoded.length){var charCode=encoded.charCodeAt(index);var value=this.decodingTable[charCode];if(value<0){throw Error("Invalid input. Encoded character '".concat(charCode,"' doesn't exist in the decoding table."))}result|=(value&31)<<shift;shift+=5;index++;// We've reached the final 5-bit chunk for this value, so return.
// We also return the index, which represents the starting index of the
// next value to decode.
if((value&32)===0){return[result,index]}}// If we've run out of encoded characters without finding an empty 6th bit,
// something has gone wrong.
throw Error("Invalid encoding - last block contained an extra 0x20 'continue' bit.")}},{key:"decodeHeader",value:function decodeHeader(encoded){// If the data has a header, the first value is expected to be the header version
// and the second value is compressed metadata containing precision and dimension information.
var _this$decodeUnsignedV3=this.decodeUnsignedValue(encoded,0),_this$decodeUnsignedV4=_slicedToArray(_this$decodeUnsignedV3,2),headerVersion=_this$decodeUnsignedV4[0],metadataIndex=_this$decodeUnsignedV4[1];if(headerVersion!==FlexiblePolylineFormatVersion){throw new Error("Invalid format version")}var _this$decodeUnsignedV5=this.decodeUnsignedValue(encoded,metadataIndex),_this$decodeUnsignedV6=_slicedToArray(_this$decodeUnsignedV5,2),metadata=_this$decodeUnsignedV6[0],nextIndex=_this$decodeUnsignedV6[1];return[{precisionLngLat:metadata&15,thirdDimension:metadata>>4&7,precisionThirdDimension:metadata>>7&15},nextIndex]}},{key:"decode",value:function decode(encoded){var encodePrecision=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;// If the data doesn't have a header, default to the passed-in precision and no 3rd dimension.
var header={precisionLngLat:encodePrecision,thirdDimension:ThirdDimension.None,precisionThirdDimension:0};// Track the index of the next character to decode from the encoded string.
var index=0;if(this.containsHeader){var _this$decodeHeader=this.decodeHeader(encoded);var _this$decodeHeader2=_slicedToArray(_this$decodeHeader,2);header=_this$decodeHeader2[0];index=_this$decodeHeader2[1]}var numDimensions=header.thirdDimension?3:2;var outputLngLatArray=[];// The data either contains lat/lng or lat/lng/z values that will be decoded.
// precisionDivisors are the divisors needed to convert the values from integers
// back to floating-point.
var precisionDivisors=[Math.pow(10,header.precisionLngLat),Math.pow(10,header.precisionLngLat),Math.pow(10,header.precisionThirdDimension)];// maxAllowedValues are the maximum absolute values allowed for lat/lng/z. This is used for
// error-checking the coordinate values as they're being decoded.
var maxAllowedValues=[90,180,Infinity];// While decoding, we want to switch from lat/lng/z to lng/lat/z, so this index tells us
// what position to put the dimension in for the resulting coordinate.
var resultDimensionIndex=[1,0,2];// Decoded values are deltas from the previous coordinate values, so track the previous values.
var lastScaledCoordinate=[0,0,0];// Keep decoding until we reach the end of the string.
while(index<encoded.length){// Each time through the loop we'll decode one full coordinate.
var coordinate=[];var deltaValue=0;// Decode each dimension for the coordinate.
for(var dimension=0;dimension<numDimensions;dimension+=1){if(index>=encoded.length){throw Error("Encoding unexpectedly ended early.")}var _this$decodeSignedVal=this.decodeSignedValue(encoded,index);var _this$decodeSignedVal2=_slicedToArray(_this$decodeSignedVal,2);deltaValue=_this$decodeSignedVal2[0];index=_this$decodeSignedVal2[1];lastScaledCoordinate[dimension]+=deltaValue;// Get the final lat/lng/z value by scaling the integer back down based on the number of
// digits of precision.
var value=lastScaledCoordinate[dimension]/precisionDivisors[dimension];if(Math.abs(value)>maxAllowedValues[dimension]){throw Error("Invalid input. Compressed data contains invalid coordinate value: ".concat(value))}coordinate[resultDimensionIndex[dimension]]=value}outputLngLatArray.push(coordinate)}return[outputLngLatArray,header]}}])}();// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// This class implements the Encoded Polyline Algorithm Format
// (https://developers.google.com/maps/documentation/utilities/polylinealgorithm).
// This algorithm is commonly used with either 5 or 6 bits of precision.
// To improve usability and decrease user error, we present Polyline5 and Polyline6
// as two distinct compression algorithms.
var EncodedPolyline=/*#__PURE__*/function(_DataCompressor){function EncodedPolyline(precision){var _this2;_classCallCheck(this,EncodedPolyline);_this2=_callSuper(this,EncodedPolyline);// The original Encoded Polyline algorithm doesn't support having a header on the encoded data.
_this2.DataContainsHeader=false;_this2.PolylineEncodingTable="?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";// The lookup table contains conversion values for ASCII characters 0-127.
// Only the characters listed in the encoding table will contain valid
// decoding entries below.
_this2.PolylineDecodingTable=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,-1];_this2.encoder=new PolylineEncoder(_this2.PolylineEncodingTable,_this2.DataContainsHeader);_this2.decoder=new PolylineDecoder(_this2.PolylineDecodingTable,_this2.DataContainsHeader);_this2.precision=precision;return _this2}_inherits(EncodedPolyline,_DataCompressor);return _createClass(EncodedPolyline,[{key:"compressLngLatArray",value:function compressLngLatArray(lngLatArray){return this.encoder.encode(lngLatArray,this.precision)}},{key:"decompressLngLatArray",value:function decompressLngLatArray(compressedData){var _this$decoder$decode=this.decoder.decode(compressedData,this.precision),_this$decoder$decode2=_slicedToArray(_this$decoder$decode,2),lngLatArray=_this$decoder$decode2[0],header=_this$decoder$decode2[1];return[lngLatArray,{precisionLngLat:header.precisionLngLat}]}}])}(DataCompressor);// Polyline5 and Polyline6 encodes/decodes compressed data with 5 or 6 bits of precision respectively.
// While the underlying Polyline implementation allows for an arbitrary
// number of bits of precision to be encoded / decoded, location service providers seem
// to only choose 5 or 6 bits of precision, so those are the two algorithms that we'll explicitly offer here.
var Polyline5=/*#__PURE__*/function(_EncodedPolyline){function Polyline5(){_classCallCheck(this,Polyline5);return _callSuper(this,Polyline5,[5])}_inherits(Polyline5,_EncodedPolyline);return _createClass(Polyline5)}(EncodedPolyline);var Polyline6=/*#__PURE__*/function(_EncodedPolyline2){function Polyline6(){_classCallCheck(this,Polyline6);return _callSuper(this,Polyline6,[6])}_inherits(Polyline6,_EncodedPolyline2);return _createClass(Polyline6)}(EncodedPolyline);// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// This class implements the Flexible-Polyline variation of the
// Encoded Polyline algorithm (https://github.com/heremaps/flexible-polyline).
// The algorithm supports both 2D and 3D data.
var FlexiblePolyline=/*#__PURE__*/function(_DataCompressor2){function FlexiblePolyline(){var _this3;_classCallCheck(this,FlexiblePolyline);_this3=_callSuper(this,FlexiblePolyline);_this3.DataContainsHeader=true;_this3.FlexPolylineEncodingTable="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";// The lookup table contains conversion values for ASCII characters 0-127.
// Only the characters listed in the encoding table will contain valid
// decoding entries below.
_this3.FlexPolylineDecodingTable=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,63,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];_this3.encoder=new PolylineEncoder(_this3.FlexPolylineEncodingTable,_this3.DataContainsHeader);_this3.decoder=new PolylineDecoder(_this3.FlexPolylineDecodingTable,_this3.DataContainsHeader);return _this3}_inherits(FlexiblePolyline,_DataCompressor2);return _createClass(FlexiblePolyline,[{key:"compressLngLatArray",value:function compressLngLatArray(lngLatArray,parameters){// Set any parameters that weren't passed in to their default values.
var DefaultCompressionParameters={precisionLngLat:DefaultPrecision,precisionThirdDimension:DefaultPrecision,thirdDimension:ThirdDimension.None};var fullParameters=Object.assign(Object.assign({},DefaultCompressionParameters),parameters);return this.encoder.encode(lngLatArray,fullParameters.precisionLngLat,fullParameters.thirdDimension,fullParameters.precisionThirdDimension)}},{key:"decompressLngLatArray",value:function decompressLngLatArray(encodedData){var _this$decoder$decode3=this.decoder.decode(encodedData),_this$decoder$decode4=_slicedToArray(_this$decoder$decode3,2),lngLatArray=_this$decoder$decode4[0],header=_this$decoder$decode4[1];return[lngLatArray,header]}}])}(DataCompressor);// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: MIT-0
// The default algorithm is FlexiblePolyline. This was selected as it is the newest and most flexible format
// of the different decoding types supported.
var compressor=new FlexiblePolyline;/** Get the currently-selected compression algorithm.
 * @returns The current compression algorithm.
 */function getCompressionAlgorithm(){if(compressor instanceof FlexiblePolyline){return CompressionAlgorithm.FlexiblePolyline}if(compressor instanceof Polyline5){return CompressionAlgorithm.Polyline5}if(compressor instanceof Polyline6){return CompressionAlgorithm.Polyline6}throw new Error("Invalid polyline compression algorithm.")}/** Set the compression algorithm to use for subsequent encode/decode calls.
 * @param compressionType The compression algorithm to use.
 * @throws Error() if an invalid compression algorithm is specified.
 */function setCompressionAlgorithm(compressionType){switch(compressionType){case CompressionAlgorithm.FlexiblePolyline:{if(!(compressor instanceof FlexiblePolyline)){compressor=new FlexiblePolyline}break}case CompressionAlgorithm.Polyline5:{if(!(compressor instanceof Polyline5)){compressor=new Polyline5}break}case CompressionAlgorithm.Polyline6:{if(!(compressor instanceof Polyline6)){compressor=new Polyline6}break}default:{throw new Error("Invalid polyline compression algorithm.")}}}/** Encode the provided array of coordinate values into an encoded string.
 * @remarks
 * This takes in an array of two-dimensional or three-dimensional positions and encodes them into
 * the currently-selected compression format.
 * Example of 2D input data:
 * ```typescript
 *   [ [5.0, 0.0], [10.0, 5.0], [10.0, 10.0], ]
 * ```
 * Example of 3D input data:
 * ```typescript
 *   [ [5.0, 0.0, 200.0], [10.0, 5.0, 200.0], [10.0, 10.0, 205.0], ]
 * ```
 * @param lngLatArray  An array of lng/lat positions to encode. The positions may contain an optional 3rd dimension.
 * @param parameters Optional compression parameters. These are currently only used by the FlexiblePolyline algorithm.
 * @returns An encoded string containing the compressed coordinate values.
 * @throws Error() if the input data contains no coordinate pairs,
 * latitude values outside of [-90, 90], longitude values outside of [-180, 180],
 * data that isn't 2-dimensional or 3-dimensional, or data that is 3-dimensional with a compressor that doesn't support 3D data.
 */function encodeFromLngLatArray(lngLatArray){var parameters=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return compressor.encodeFromLngLatArray(lngLatArray,parameters)}/** Decode the provided encoded data string into an array of coordinate values.
 * @remarks
 * Note that this method returns a raw array of coordinate values, which cannot be used as a MapLibre source
 * without first embedding it into a GeoJSON Feature. If you want to add the decoded data as a MapLibre source,
 * use either {@link decodeToLineStringFeature} or {@link decodeToPolygonFeature} instead.
 * Only use this method when you want to use the coordinate data directly.
 * @param compressedData  The encoded data string to decode. The data is expected to have valid lat/lng values.
 * @returns An array of coordinate value arrays.
 * @throws Error() if the encodedData contains invalid characters, no coordinate pairs,
 * latitude values outside of [-90, 90], or longitude values outside of [-180, 180].
 * @example
 * An example of decoded data:
 * ```typescript
 *   [
 *     [5.0, 0.0],
 *     [10.0, 5.0],
 *     [10.0, 10.0],
 *   ]
 * ```
 */function decodeToLngLatArray(compressedData){return compressor.decodeToLngLatArray(compressedData)}/** Decode the provided encoded data string into a GeoJSON LineString.
 * @remarks
 * Note that this method returns a LineString, which cannot be used as a MapLibre source without first embedding it
 * into a GeoJSON Feature. If you want to add the LineString as a MapLibre source, use {@link decodeToLineStringFeature} instead.
 * Only use this method when you plan to manipulate the LineString further as opposed to using it directly as a source.
 * @param encodedData  The encoded data string to decode. The data is expected to have a minimum of two
 * coordinate pairs with valid lat/lng values.
 * @returns A GeoJSON LineString representing the decoded data.
 * @throws Error() if the encodedData contains invalid characters, < 2 coordinate pairs,
 * latitude values outside of [-90, 90], or longitude values outside of [-180, 180].
 * @example
 * An example of a decoded LineString:
 * ```json
 * {
 *   "type": "LineString",
 *   "coordinates": [
 *     [5.0, 0.0],
 *     [10.0, 5.0],
 *     [10.0, 10.0],
 *   ]
 * }
 * ```
 */function decodeToLineString(encodedData){return compressor.decodeToLineString(encodedData)}/** Decode the provided encoded data string into a GeoJSON Polygon.
 * @remarks
 * Note that this method returns a Polygon, which cannot be used as a MapLibre source without first embedding it
 * into a GeoJSON Feature. If you want to add the Polygon as a MapLibre source, use {@link decodeToPolygonFeature} instead.
 * Only use this method when you plan to manipulate the Polygon further as opposed to using it directly as a source.
 * @param encodedData  An array of encoded data strings to decode. This is an array instead of a single string
 * because polygons can consist of multiple rings of compressed data. The first entry will be treated as the
 * outer ring and the remaining entries will be treated as inner rings. Each input ring can be wound either
 * clockwise or counterclockwise; they will get rewound to be GeoJSON-compliant in the output. Each ring is
 * expected to have a minimum of four coordinate pairs with valid lat/lng data, and the last coordinate pair
 * must match the first to make an explicit ring.
 * @returns A GeoJSON Polygon representing the decoded data. The first entry in the output coordinates
 * represents the outer ring and any remaining entries represent inner rings.
 * @throws Error() if the encodedData contains invalid characters, < 4 coordinate pairs, first/last coordinates that
 * aren't approximately equal, latitude values outside of [-90, 90], or longitude values outside of [-180, 180].
 * @example
 * An example of a decoded Polygon:
 * ```json
 * {
 *   "type": "Polygon",
 *   "coordinates": [
 *     [[0, 0], [10, 0], [10, 10], [0, 10], [0, 0]], // outer ring
 *     [[2, 2], [2,  8], [8 , 8 ], [8 , 2], [2, 2]], // inner ring
 *     [[4, 4], [4,  6], [6 , 6 ], [6 , 4], [4, 4]]  // inner ring
 *   ]
 * }
 * ```
 */function decodeToPolygon(encodedData){return compressor.decodeToPolygon(encodedData)}/** Decode the provided encoded data string into a GeoJSON Feature containing a LineString.
 * @param encodedData  The encoded data string to decode. The data is expected to have a minimum of two
 * coordinate pairs with valid lat/lng values.
 * @returns A GeoJSON Feature containing a LineString that represents the decoded data.
 * @throws Error() if the encodedData contains invalid characters, < 2 coordinate pairs,
 * latitude values outside of [-90, 90], or longitude values outside of [-180, 180]
 * @example
 * An example of a decoded LineString as a Feature:
 * ```json
 * {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [5.0, 0.0],
 *       [10.0, 5.0],
 *       [10.0, 10.0],
 *     ]
 *   }
 * }
 * ```
 * The result of this method can be used with MapLibre's `addSource` to add a named data source or embedded directly
 * with MapLibre's `addLayer` to both add and render the result:
 * ```javascript
 * var decodedGeoJSON = polylineDecoder.decodeToLineStringFeature(encodedRoutePolyline);
 * map.addLayer({
 *   id: 'route',
 *   type: 'line',
 *     source: {
 *       type: 'geojson',
 *       data: decodedGeoJSON
 *     },
 *     layout: {
 *       'line-join': 'round',
 *       'line-cap': 'round'
 *     },
 *       paint: {
 *         'line-color': '#3887be',
 *         'line-width': 5,
 *         'line-opacity': 0.75
 *       }
 * });
 * ```
 */function decodeToLineStringFeature(encodedData){return compressor.decodeToLineStringFeature(encodedData)}/** Decode the provided encoded data string into a GeoJSON Feature containing a Polygon.
 * @param encodedData  An array of encoded data strings to decode. This is an array instead of a single string
 * because polygons can consist of multiple rings of compressed data. The first entry will be treated as the
 * outer ring and the remaining entries will be treated as inner rings. Each input ring can be wound either
 * clockwise or counterclockwise; they will get rewound to be GeoJSON-compliant in the output. Each ring is
 * expected to have a minimum of four coordinate pairs with valid lat/lng data, and the last coordinate pair
 * must match the first to make an explicit ring.
 * @returns A GeoJSON Feature containing a Polygon that represents the decoded data. The first entry in the
 * output coordinates represents the outer ring and any remaining entries represent inner rings.
 * @throws Error() if the encodedData contains invalid characters, < 4 coordinate pairs, first/last coordinates that
 * aren't approximately equal, latitude values outside of [-90, 90], or longitude values outside of [-180, 180].
 * @example
 * An example of a decoded Polygon as a Feature:
 * ```json
 * {
 *   'type': 'Feature',
 *   'properties': {},
 *   'geometry': {
 *     "type": "Polygon",
 *     "coordinates": [
 *       [[0, 0], [10, 0], [10, 10], [0, 10], [0, 0]], // outer ring
 *       [[2, 2], [2,  8], [8 , 8 ], [8 , 2], [2, 2]], // inner ring
 *       [[4, 4], [4,  6], [6 , 6 ], [6 , 4], [4, 4]]  // inner ring
 *     ]
 *   }
 * }
 * ```
 * The result of this method can be used with MapLibre's `addSource` to add a named data source or embedded directly
 * with MapLibre's `addLayer` to both add and render the result:
 * ```javascript
 * var decodedGeoJSON = polylineDecoder.decodeToPolygonFeature(encodedIsolinePolygons);
 * map.addLayer({
 *   id: 'isoline',
 *   type: 'fill',
 *     source: {
 *       type: 'geojson',
 *       data: decodedGeoJSON
 *     },
 *     layout: {},
 *     paint: {
 *       'fill-color': '#FF0000',
 *       'fill-opacity': 0.6
       }
 * });
 * ```
 */function decodeToPolygonFeature(encodedData){return compressor.decodeToPolygonFeature(encodedData)}});
